<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>霍格沃茨QQ模拟器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <style>
        :root {
            --theme-dark: #1a472a; --theme-light: #5d8a5f; --theme-bubble: rgba(26, 71, 42, 0.3); --theme-accent: #d3a625;
            --slytherin-dark: #1a472a; --slytherin-light: #5d8a5f; --gryffindor-dark: #740001; --gryffindor-light: #ae0001;
            --hufflepuff-dark: #372e29; --hufflepuff-light: #ecb939; --ravenclaw-dark: #1C51A3; --ravenclaw-light: #4993C5;
            --dark-bg: #111418; --light-bg: #1c252e;
            --main-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--main-font); -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        body { background: linear-gradient(135deg, #0a1429 0%, #1c252e 50%, #283446 100%); color: #f0e6d2; display: flex; justify-content: center; align-items: center; position: relative; }
        body::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none" stroke="%230d1522" stroke-width="2"/></svg>'); background-size: 60px; opacity: 0.4; z-index: -1; }
        
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111418;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            transition: opacity 0.5s ease-out;
            font-family: 'Cinzel', serif;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .splash-logo {
            font-size: 28px;
            color: var(--theme-accent);
            text-shadow: 0 0 10px var(--theme-accent);
            margin-bottom: 25px;
        }
        .splash-loader {
            width: 50px;
            height: 50px;
            border: 3px solid var(--theme-bubble);
            border-top-color: var(--theme-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .setup-container { width: 100%; max-width: 700px; padding: 25px; border-radius: 20px; background: rgba(24, 30, 40, 0.9); backdrop-filter: blur(5px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); border: 1px solid rgba(255,255,255,0.1); }
        .setup-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
        .form-group { display: flex; flex-direction: column; }
        .form-group.full-width { grid-column: 1 / -1; }
        .form-group label { margin-bottom: 8px; font-weight: 600; opacity: 0.9; }
        .form-group input, .form-group select, .form-group textarea { padding: 12px 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(20, 30, 40, 0.8); color: white; font-size: 16px; -webkit-user-select: text; user-select: text; }
        .form-group textarea { resize: vertical; min-height: 80px; }
        .wand-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        #startAdventureBtn { grid-column: 1 / -1; margin-top: 15px; padding: 15px; border-radius: 10px; border: none; background: linear-gradient(to right, var(--theme-dark), var(--theme-light)); color: white; font-size: 18px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; }
        .container { display: flex; flex-direction: column; width: 100%; height: 100vh; height: 100svh; background: rgba(24, 30, 40, 0.9); backdrop-filter: blur(5px); position: relative; }
        .view-header { background: linear-gradient(135deg, var(--theme-dark), var(--theme-light)); padding: 18px 20px; display: flex; justify-content: space-between; align-items: center; position: relative; z-index: 2; box-shadow: 0 4px 10px rgba(0,0,0,0.3); flex-shrink: 0; }
        .view-header h2 { font-weight: 700; font-size: 22px; text-shadow: 0 2px 4px rgba(0,0,0,0.4); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .view-header .back-button { background: rgba(0,0,0,0.2); border: none; color: white; padding: 7px 12px; border-radius: 20px; cursor: pointer; display: flex; align-items: center; gap: 5px; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        .view-header i { font-size: 22px; cursor: pointer; }
        .view-content { flex: 1; padding: 20px; overflow-y: auto; position: relative; -webkit-overflow-scrolling: touch; }
        .navigation { display: grid; grid-template-columns: repeat(4, 1fr); background: rgba(30, 40, 50, 0.8); padding: 8px 0; border-top: 1px solid rgba(255, 255, 255, 0.2); flex-shrink: 0; }
        .nav-item { text-align: center; padding: 8px; font-size: 14px; cursor: pointer; transition: all 0.3s; border-radius: 8px; margin: 0 5px; }
        .nav-item:hover, .nav-item.active { background: var(--theme-bubble); }
        .nav-item i { font-size: 22px; margin-bottom: 4px; display: block; }
        .card { background: rgba(40, 50, 65, 0.7); border-radius: 15px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); }
        .avatar { background-size: cover; background-position: center; cursor: pointer; }
        .profile-header { display: flex; align-items: center; margin-bottom: 25px; }
        .profile-avatar { width: 100px; height: 100px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.7); background-color: #2c3e50; box-shadow: 0 4px 10px rgba(0,0,0,0.3); margin-right: 20px; flex-shrink: 0; }
        .profile-details { flex: 1; min-width: 0; }
        .profile-name { font-size: 24px; font-weight: 700; margin-bottom: 5px; display: flex; align-items: center; flex-wrap: wrap; cursor: pointer; }
        .info-grid { display: grid; grid-template-columns: auto 1fr; gap: 12px 20px; margin-top: 15px; padding: 10px 0; }
        .info-label { font-weight: bold; color: var(--theme-light); text-align: right; }
        .info-value { font-weight: 500; white-space: pre-wrap; word-break: break-word; }
        .info-value.editable:hover { background-color: var(--theme-bubble); cursor: pointer; border-radius: 5px; padding: 2px 5px; }
        .btn { padding: 12px 20px; border-radius: 10px; border: none; font-weight: 600; font-size: 16px; cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center; justify-content: center; gap: 8px; color: white; margin: 0 5px 10px 0; }
        .btn.primary { background: linear-gradient(to right, var(--theme-dark), var(--theme-light)); }
        .btn.logout { background: linear-gradient(to right, #c0392b, #e74c3c); }
        .chat-list { display: flex; flex-direction: column; gap: 12px; }
        .chat-item { display: flex; padding: 12px; border-radius: 12px; background: rgba(40, 50, 65, 0.5); border: 1px solid rgba(255,255,255,0.05); cursor: pointer; transition: all 0.2s; position: relative; }
        .chat-avatar { width: 60px; height: 60px; border-radius: 50%; margin-right: 15px; display: flex; justify-content: center; align-items: center; font-size: 28px; color: white; flex-shrink: 0; }
        .chat-content { flex: 1; min-width: 0; }
        .chat-header { display: flex; justify-content: space-between; margin-bottom: 5px; font-weight: 600; }
        .chat-header div:last-child { font-size: 13px; opacity: 0.7; flex-shrink: 0; }
        .chat-window { display: flex; flex-direction: column; height: 100%; position: relative; }
        .chat-history { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px; background: rgba(15, 22, 33, 0.4); border-radius: 12px; transition: background-image 0.5s ease; -webkit-overflow-scrolling: touch; }
        .chat-history.has-custom-bg .message.incoming { background: rgba(60, 80, 100, 0.85); }
        .chat-history.has-custom-bg .message.outgoing { background: linear-gradient(to right, rgba(93, 138, 95, 0.85), rgba(26, 71, 42, 0.85)); }
        .message { max-width: 80%; padding: 12px 15px; border-radius: 18px; margin: 5px 0; position: relative; animation: fadeIn 0.3s; word-wrap: break-word; box-shadow: 0 2px 4px rgba(0,0,0,0.1); -webkit-user-select: none; user-select: none; }
        .message.incoming { background: rgba(60, 80, 100, 0.6); align-self: flex-start; }
        .message.outgoing { background: var(--theme-light); align-self: flex-end; }
        .message-sender { font-size: 12px; font-weight: bold; margin-bottom: 4px; color: var(--theme-accent); }
        .message-time { font-size: 10px; opacity: 0.7; padding-left: 10px; display: inline-block; }
        .message-text { display: inline; white-space: pre-wrap; -webkit-user-select: text; user-select: text; line-height: 1.6; letter-spacing: 0.5px; }
        .message-image { max-width: 100%; border-radius: 10px; margin-top: 8px; }
        .message-emoji { max-width: 100px; max-height: 100px; display: block; }
        .message-quote { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 8px; position: relative; padding-left: 25px; }
        .message-quote::before { content: '“'; font-family: 'Cinzel', serif; font-size: 40px; position: absolute; left: 5px; top: 0; line-height: 1; opacity: 0.5; }
        .gift-card { display: flex; align-items: center; gap: 15px; background: #f0e6d2; color: #333; padding: 15px; border-radius: 10px; max-width: 300px; }
        .gift-image { width: 60px; height: 60px; object-fit: cover; border-radius: 8px; flex-shrink: 0; }
        .gift-image-default { width: 60px; height: 60px; border-radius: 8px; flex-shrink: 0; font-size: 3em; display: flex; align-items: center; justify-content: center; background-color: #ddd; color: #333;}
        .gift-details { flex-grow: 1; }
        .gift-title { font-weight: bold; font-size: 1.1em; }
        .gift-message { font-size: 0.9em; opacity: 0.8; margin: 4px 0; }
        .gift-price { font-size: 1.1em; font-weight: bold; color: #c0392b; }
        .chat-input-area { display: flex; flex-direction: column; gap: 10px; padding: 10px; background: transparent; flex-shrink: 0; position: relative; }
        .chat-input-row { display: flex; gap: 8px; align-items: center; }
        .chat-input { flex: 1; position: relative; }
        .chat-input input { width: 100%; padding: 12px 15px; border-radius: 20px; border: none; background: rgba(20, 30, 40, 0.8); color: white; font-size: 16px; -webkit-user-select: text; user-select: text;}
        .chat-actions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; }
        .action-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px; border-radius: 10px; background: var(--theme-light); color: white; border: none; cursor: pointer; font-size: 12px; gap: 4px; }
        .action-btn.active { background: var(--theme-accent); color: var(--dark-bg); }
        .action-btn i { font-size: 18px; }
        .send-btn { background: #F5F5DC; color: #000000; border: none; cursor: pointer; border-radius: 20px; padding: 0 18px; height: 45px; font-size: 16px; font-weight: 600; }
        .emoji-panel { position: absolute; bottom: 100%; left: 0; right: 0; background: var(--dark-bg); border-top: 1px solid var(--theme-light); border-radius: 15px 15px 0 0; padding: 15px; z-index: 100; display: none; }
        .emoji-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .emoji-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 200px; overflow-y: auto; }
        .emoji-item { width: 60px; height: 60px; object-fit: contain; cursor: pointer; background: rgba(255,255,255,0.1); border-radius: 8px; padding: 5px; }
        .emoji-item-add { display: flex; justify-content: center; align-items: center; font-size: 24px; border: 2px dashed var(--theme-light); }
        .moment-item { background: rgba(40, 50, 65, 0.7); border-radius: 15px; padding: 20px; margin-bottom: 20px; }
        .moment-header { display: flex; align-items: center; margin-bottom: 15px; }
        .moment-avatar { width: 50px; height: 50px; border-radius: 50%; margin-right: 12px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; flex-shrink: 0; }
        .moment-user { flex: 1; min-width: 0; }
        .moment-name { font-weight: 600; font-size: 16px; }
        .moment-time { font-size: 13px; opacity: 0.7; }
        .moment-content { margin-bottom: 15px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; -webkit-user-select: text; user-select: text; }
        .moment-image { width: 100%; max-height: 300px; object-fit: cover; border-radius: 10px; margin-top: 10px; }
        .moment-footer { display: flex; gap: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; margin-top: 15px; }
        .moment-footer-action { cursor: pointer; display: flex; align-items: center; gap: 5px; opacity: 0.8; transition: all 0.2s; }
        .moment-footer-action.liked { color: #e74c3c; opacity: 1; }
        .moment-footer-action:hover { opacity: 1; color: var(--theme-light); }
        .moment-comments { margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }
        .comment { font-size: 14px; margin-bottom: 8px; cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: background-color 0.2s; }
        .comment:hover { background-color: rgba(255,255,255,0.05); }
        .comment strong { color: var(--theme-light); }
        .comment .reply-to { color: var(--theme-accent); opacity: 0.9; }
        .moment-comment-input-wrapper { margin-top: 15px; display: none; }
        .moment-comment-input-wrapper.active { display: flex; gap: 8px; }
        .moment-comment-input-wrapper input { flex: 1; padding: 8px 12px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2); background: rgba(20, 30, 40, 0.8); color: white; -webkit-user-select: text; user-select: text; }
        .moment-comment-input-wrapper button { padding: 8px 15px; border-radius: 15px; border: none; background: var(--theme-light); color: white; cursor: pointer; }
        .friends-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; }
        .friend-item { position: relative; background: rgba(40, 50, 65, 0.6); border-radius: 10px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .friend-avatar { width: 70px; height: 70px; border-radius: 50%; margin: 0 auto 10px; border: 2px solid var(--theme-light); display: flex; justify-content: center; align-items: center; font-size: 32px; color: white;}
        .view-title { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--theme-bubble); display: flex; align-items: center; gap: 10px; }
        .hidden { display: none !important; }
        .wizard-dialog { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .dialog-content { background: var(--dark-bg); border-radius: 15px; padding: 25px; width: 90%; max-width: 500px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); border: 2px solid var(--theme-light); position: relative; }
        .dialog-title { font-size: 1.5rem; margin-bottom: 20px; color: var(--theme-light); text-align: center; }
        .dialog-actions { display: flex; flex-direction: row; gap: 10px; margin-top: 20px; justify-content: flex-end; }
        .dialog-btn { padding: 10px 20px; border-radius: 8px; border: none; font-weight: 600; cursor: pointer; background: var(--theme-light); color: white; text-align: center; }
        .dialog-btn.cancel-btn { background: #6c757d; }
        .close-dialog-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: #f0e6d2; font-size: 2rem; cursor: pointer; line-height: 1; padding: 0; }
        .tabs { display: flex; border-bottom: 1px solid var(--theme-bubble); margin-bottom: 15px; }
        .tab { padding: 10px 15px; cursor: pointer; opacity: 0.7; flex-grow: 1; text-align: center; }
        .tab.active { opacity: 1; border-bottom: 2px solid var(--theme-light); }
        .image-preview { max-width: 100px; max-height: 100px; border-radius: 8px; margin-top: 10px; }
        #context-menu { position: fixed; z-index: 2000; background: var(--dark-bg); border: 1px solid var(--theme-light); border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); padding: 5px 0; min-width: 150px; }
        .context-menu-item { padding: 8px 15px; cursor: pointer; }
        .context-menu-item:hover { background-color: var(--theme-light); }
        .context-menu-item.disabled { opacity: 0.5; cursor: not-allowed; }
        .model-group { display: flex; gap: 10px; align-items: center; }
        .model-group select { flex-grow: 1; }
        .group-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 5px; margin-top: 15px; border-bottom: 1px solid var(--theme-bubble); }
        .group-name { color: var(--theme-light); font-size: 1.1em; }
        .manage-groups-list { max-height: 60vh; overflow-y: auto; padding-right: 10px;}
        .group-manage-item { border: 1px solid var(--theme-bubble); border-radius: 8px; margin-bottom: 10px; overflow: hidden; }
        .group-manage-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; background: rgba(255,255,255,0.05); cursor: pointer; }
        .group-manage-header-name { display: flex; align-items: center; gap: 10px; }
        .group-manage-header-name .fa-thumbtack { color: var(--theme-accent); }
        .header-arrow { transition: transform 0.3s ease; }
        .header-arrow.expanded { transform: rotate(180deg); }
        .group-manage-members { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; background: rgba(0,0,0,0.2); }
        .group-manage-members.expanded { max-height: 500px; }
        .group-member-item { display: flex; align-items: center; gap: 12px; padding: 8px 15px; border-top: 1px solid var(--theme-bubble); }
        .group-member-item .avatar { width: 35px; height: 35px; flex-shrink: 0; font-size: 18px; }
        .move-to-group-option { padding: 12px 15px; cursor: pointer; border-radius: 8px; margin-bottom: 8px; background: rgba(255,255,255,0.05); transition: background-color 0.2s; }
        .move-to-group-option:hover { background-color: var(--theme-bubble); }
        .move-to-group-option.current { font-weight: bold; color: var(--theme-accent); }
        .twt-button-list { display: flex; flex-direction: column; gap: 15px; }
        .twt-button { padding: 15px 20px; border-radius: 12px; border: 1px solid var(--theme-accent); background: linear-gradient(135deg, rgba(211, 166, 37, 0.1), rgba(211, 166, 37, 0.2)); color: #f0e6d2; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-align: left; }
        .twt-button:hover { background: linear-gradient(135deg, rgba(211, 166, 37, 0.2), rgba(211, 166, 37, 0.3)); border-color: #f0e6d2; }
        .save-slot-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--theme-bubble); border-radius: 8px; margin-bottom: 10px; }
        .save-slot-item label { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
        .save-slot-info { display: flex; flex-direction: column; }
        .save-slot-info .main-record-tag { font-size: 10px; color: var(--theme-accent); font-weight: bold; }
        
        /* ✨ 新增的搜索结果样式 */
        .search-results-container {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 10px;
        }
        .search-result-item {
            padding: 12px;
            border-bottom: 1px solid var(--theme-bubble);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-result-item:hover {
            background-color: var(--theme-bubble);
        }
        .search-result-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 6px;
            opacity: 0.8;
        }
        .search-result-header .time {
            font-size: 12px;
        }
        .search-result-content {
            font-size: 15px;
            line-height: 1.5;
            word-break: break-word;
        }
        .search-result-content .highlight {
            background-color: var(--theme-accent);
            color: var(--dark-bg);
            padding: 1px 3px;
            border-radius: 3px;
        }
        @media (max-width: 768px) {
            .setup-container { width: 100%; height: 100%; max-height: 100vh; border-radius: 0; overflow-y: auto; padding: 20px 15px; }
            .setup-grid { grid-template-columns: 1fr; }
            .wand-group { grid-template-columns: 1fr; }
            .profile-name { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <div class="splash-logo">Welcome to Hogwarts</div>
        <div class="splash-loader"></div>
    </div>
    <div id="app-root"></div>
    <div id="context-menu" class="hidden"></div>
<script>
function startApp() {
    (async function() {
        let appHasInitialized = false; 
        setTimeout(() => {
            if (!appHasInitialized) {
                const splash = document.getElementById('splash-screen');
                if (splash) {
                    splash.innerHTML = `
                        <div style="color: #ff4d4d; text-align: center; padding: 20px; font-family: sans-serif;">
                            <h3 style="margin-bottom: 15px;">应用加载超时</h3>
                            <p style="font-size: 14px; line-height: 1.6;">应用未能成功启动，可能是由于浏览器限制或数据损坏。</p>
                            <p style="font-size: 12px; margin-top: 20px; color: #aaa;">请尝试以下操作：<br>1. 彻底关闭并重启浏览器。<br>2. 清除浏览器缓存/网站数据。<br>3. 在隐私/无痕模式下打开文件。</p>
                        </div>
                    `;
                }
            }
        }, 10000); 
        const appRoot = document.getElementById('app-root');
        const contextMenu = document.getElementById('context-menu');
        const setupTemplate = `<div class="setup-container" id="setupContainer"><h2 class="setup-title">创建你的巫师档案</h2><div class="setup-grid"><div class="form-group"><label>姓</label><input type="text" id="userLastName" placeholder="布莱克"></div><div class="form-group"><label>名</label><input type="text" id="userFirstName" placeholder="奥利维娅"></div><div class="form-group"><label>性别</label><select id="userGender"><option value="女">女</option><option value="男">男</option></select></div><div class="form-group"><label>学院</label><select id="userHouse"><option value="slytherin">斯莱特林</option><option value="gryffindor">格兰芬多</option><option value="hufflepuff">赫奇帕奇</option><option value="ravenclaw">拉文克劳</option></select></div><div class="form-group"><label>血统</label><select id="userBlood"><option value="纯血">纯血</option><option value="混血">混血</option><option value="麻瓜出身">麻瓜出身</option></select></div><div class="form-group"><label>年龄</label><select id="userAgeYear"><option value="11岁 (一年级)">11岁 (一年级)</option><option value="12岁 (二年级)">12岁 (二年级)</option><option value="13岁 (三年级)">13岁 (三年级)</option><option value="14岁 (四年级)" selected>14岁 (四年级)</option><option value="15岁 (五年级)">15岁 (五年级)</option><option value="16岁 (六年级)">16岁 (六年级)</option><option value="17岁 (七年级)">17岁 (七年级)</option></select></div><div class="form-group full-width"><label>魔杖</label><div class="wand-group"><select id="wandCore"><option value="龙心弦">杖芯：龙心弦</option><option value="凤凰尾羽">杖芯：凤凰尾羽</option><option value="独角兽毛">杖芯：独角兽毛</option></select><input type="text" id="wandWood" placeholder="木材"><input type="text" id="wandLength" placeholder="长度"><input type="text" id="wandFlex" placeholder="柔韧度"></div></div><div class="form-group"><label>守护神</label><input type="text" id="userPatronus" placeholder="例如：黑曼巴蛇"></div><div class="form-group"><label>宠物</label><input type="text" id="userPet" placeholder="例如：栗色猫头鹰"></div><div class="form-group full-width"><label>外貌特征</label><textarea id="userAppearance" placeholder="例如：深棕色卷发，灰色虹膜"></textarea></div><div class="form-group full-width"><label>性格特征</label><textarea id="userPersonality" placeholder="例如：骄傲敏锐，重视传统"></textarea></div><div class="form-group full-width"><label>身份背景</label><textarea id="userIdentity" placeholder="例如：来自一个古老的纯血家族，对黑魔法有浓厚兴趣"></textarea></div><div class="form-group full-width"><label>个性签名</label><input type="text" id="userSignature" placeholder="荣耀永恒"></div><button id="startAdventureBtn">进入霍格沃茨</button></div></div>`;
        const mainTemplate = `<div style="position: absolute; width: 300px; height: 300px; border-radius: 50%; background: radial-gradient(circle, var(--theme-bubble) 0%, rgba(0,0,0,0) 70%); pointer-events: none; top: -100px; right: -100px; animation: float 6s ease-in-out infinite;"></div><div style="position: absolute; width: 300px; height: 300px; border-radius: 50%; background: radial-gradient(circle, var(--theme-bubble) 0%, rgba(0,0,0,0) 70%); pointer-events: none; bottom: -80px; left: -50px; animation: float 8s ease-in-out infinite; animation-delay: 1s;"></div><div class="container" id="mainContainer"><div class="view-header"><button class="back-button hidden" id="backButton"><i class="fas fa-arrow-left"></i> 返回</button><h2 id="viewTitle">霍格沃茨QQ</h2><i class="fas fa-cog" id="settingsBtn"></i></div><div class="view-content" id="viewContent"></div><div class="navigation"><div class="nav-item active" data-view="messages"><i class="fas fa-comment-alt"></i><span>消息</span></div><div class="nav-item" data-view="contacts"><i class="fas fa-user-friends"></i><span>联系人</span></div><div class="nav-item" data-view="moments"><i class="fas fa-newspaper"></i><span>动态</span></div><div class="nav-item" data-view="profile"><i class="fas fa-user"></i><span>我</span></div></div></div><div class="wizard-dialog hidden" id="wizardDialog"><div class="dialog-content" id="dialogContent"></div></div>`;
        
        const db = new Dexie('HogwartsVaultDB-v4');
        db.version(6).stores({
            appState: 'id',
            userProfile: 'id',
            apiConfig: 'id',
            contacts: 'id',
            chats: 'id, contactId, isGroup', 
            myMoments: 'id',
            friendMoments: 'id',
            groups: 'id',
            triwizardChapters: 'id'
        });
        
        function getDefaultContacts() { return {
            professors: [ { id: 'prof1', name: "米勒娃·麦格", house: 'gryffindor', icon: '🧑‍🏫', info: "姓名：米勒娃·麦格\n职位：变形术教授、格兰芬多院长\n简介：纪律严明但内心公正。", sharedHistory: "", avatar: null }, { id: 'prof2', name: "西弗勒斯·斯内普", house: 'slytherin', icon: '🧑‍🏫', info: "姓名：西弗勒斯·斯内普\n职位：魔药学教授、斯莱特林院长\n简介：态度严苛，言辞尖酸。", sharedHistory: "", avatar: null }, { id: 'prof3', name: "菲利乌斯·弗立维", house: 'ravenclaw', icon: '🧑‍🏫', info: "姓名：菲利乌斯·弗立维\n职位：魔咒学教授、拉文克劳院长\n简介：学识渊博，善良且强大。", sharedHistory: "", avatar: null }, { id: 'prof4', name: "波莫娜·斯普劳特", house: 'hufflepuff', icon: '🧑‍🏫', info: "姓名：波莫娜·斯普劳特\n职位：草药学教授、赫奇帕奇院长\n简介：和蔼可亲，热爱植物。", sharedHistory: "", avatar: null }, { id: 'prof5', name: "罗兰达·霍琦", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：罗兰达·霍琦\n职位：飞行课教授、魁地奇裁判\n简介：对飞行规则一丝不苟。", sharedHistory: "", avatar: null }, { id: 'prof6', name: "鲁伯·海格", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：鲁伯·海格\n职位：霍格沃茨猎场看守，保护神奇生物课教授\n简介：半巨人，性格憨厚思维简单，教学水平差，认为伤害性强的神奇生物很可爱，很难保守秘密。", sharedHistory: "", avatar: null }, { id: 'prof7', name: "波比·庞弗雷", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：波比·庞弗雷\n职位：霍格沃茨校医\n简介：医术高超。", sharedHistory: "", avatar: null }, { id: 'prof8', name: "阿格斯·费尔奇", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：阿格斯·费尔奇\n职位：霍格沃茨管理员\n简介：哑炮，不会魔法，性格尖酸扭曲，喜欢刁难学生。", sharedHistory: "", avatar: null }, { id: 'prof9', name: "奥罗拉·辛尼斯塔", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：奥罗拉·辛尼斯塔\n职位：天文学教授\n简介：性格疏离，热爱天文学。", sharedHistory: "", avatar: null }, { id: 'prof10', name: "卡斯伯特·宾斯", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：卡斯伯特·宾斯\n职位：魔法史教授\n简介：幽灵，讲课非常无聊，沉浸在自己的世界里，只知道讲课，不关心任何人。", sharedHistory: "", avatar: null }, { id: 'prof11', name: "伊尔玛·平斯", house: 'hogwarts', icon: '🧑‍🏫', info: "姓名：伊尔玛·平斯\n职位：霍格沃茨图书管理员\n简介：性格严苛，讨厌任何扰乱图书馆秩序的生物和非生物。", sharedHistory: "", avatar: null },  ],
            slytherin: [ { id: 'sly1', name: "德拉科·马尔福", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly2', name: "潘西·帕金森", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly3', name: "西奥多·诺特", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly4', name: "布雷斯·扎比尼", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly5', name: "文森特·克拉布", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly6', name: "格雷戈里·高尔", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly7', name: "达芙妮·格林格拉斯", house: "slytherin", icon: '🐍', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'sly8', name: "特伦斯·希格斯", house: "slytherin", icon: '🐍', info: "职位：魁地奇找球手", sharedHistory: "", avatar: null }, { id: 'sly9', name: "德里安·普塞", house: "slytherin", icon: '🐍', info: "职位：魁地奇追球手", sharedHistory: "", avatar: null }, { id: 'sly10', name: "杰玛·法利", house: "slytherin", icon: '🐍', info: "职位：级长", sharedHistory: "", avatar: null }, ],
            gryffindor: [ { id: 'gry1', name: "哈利·波特", house: "gryffindor", icon: '🦁', info: "简介：大难不死的男孩", sharedHistory: "", avatar: null }, { id: 'gry2', name: "罗恩·韦斯莱", house: "gryffindor", icon: '🦁', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'gry3', name: "赫敏·格兰杰", house: "gryffindor", icon: '🦁', info: "血统：麻瓜出身", sharedHistory: "", avatar: null }, { id: 'gry4', name: "弗雷德·韦斯莱", house: "gryffindor", icon: '🦁', info: "职位：魁地奇击球手", sharedHistory: "", avatar: null }, { id: 'gry5', name: "乔治·韦斯莱", house: "gryffindor", icon: '🦁', info: "职位：魁地奇击球手", sharedHistory: "", avatar: null }, { id: 'gry6', name: "安吉丽娜·约翰逊", house: "gryffindor", icon: '🦁', info: "职位：魁地奇追球手", sharedHistory: "", avatar: null }, { id: 'gry7', name: "珀西·韦斯莱", house: "gryffindor", icon: '🦁', info: "职位：级长", sharedHistory: "", avatar: null }, { id: 'gry8', name: "帕瓦蒂·佩蒂尔", house: "gryffindor", icon: '🦁', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'gry9', name: "拉文德·布朗", house: "gryffindor", icon: '🦁', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'gry10', name: "迪安·托马斯", house: "gryffindor", icon: '🦁', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'gry11', name: "西莫·斐尼甘", house: "gryffindor", icon: '🦁', info: "血统：混血", sharedHistory: "", avatar: null }, ],
            ravenclaw: [ { id: 'rav1', name: "泰瑞·布特", house: "ravenclaw", icon: '🦅', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'rav2', name: "迈克尔·科纳", house: "ravenclaw", icon: '🦅', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'rav3', name: "卢娜·洛夫古德", house: "ravenclaw", icon: '🦅', info: "简介：思想天马行空", sharedHistory: "", avatar: null }, { id: 'rav4', name: "秋·张", house: "ravenclaw", icon: '🦅', info: "职位：魁地奇找球手", sharedHistory: "", avatar: null }, { id: 'rav5', name: "安东尼·戈德斯坦", house: "ravenclaw", icon: '🦅', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'rav6', name: "帕德玛·佩蒂尔", house: "ravenclaw", icon: '🦅', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'rav7', name: "佩内洛·克里瓦特", house: "ravenclaw", icon: '🦅', info: "职位：级长", sharedHistory: "", avatar: null }, ],
            hufflepuff: [ { id: 'huf1', name: "汉娜·艾博", house: "hufflepuff", icon: '🦡', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'huf2', name: "塞德里克·迪戈里", house: "hufflepuff", icon: '🦡', info: "职位：级长、魁地奇队长", sharedHistory: "", avatar: null }, { id: 'huf3', name: "苏珊·博恩斯", house: "hufflepuff", icon: '🦡', info: "血统：混血", sharedHistory: "", avatar: null }, { id: 'huf4', name: "厄尼·麦克米兰", house: "hufflepuff", icon: '🦡', info: "血统：纯血", sharedHistory: "", avatar: null }, { id: 'huf5', name: "贾斯廷·芬列里", house: "hufflepuff", icon: '🦡', info: "血统：麻瓜出身", sharedHistory: "", avatar: null }, { id: 'huf6', name: "扎卡赖斯·史密斯", house: "hufflepuff", icon: '🦡', info: "血统：混血", sharedHistory: "", avatar: null }, ]
        };}
        const HOUSE_INFO = { slytherin: { name: '斯莱特林', icon: '🐍', colors: { dark: 'var(--slytherin-dark)', light: 'var(--slytherin-light)' } }, gryffindor: { name: '格兰芬多', icon: '🦁', colors: { dark: 'var(--gryffindor-dark)', light: 'var(--gryffindor-light)' } }, ravenclaw: { name: '拉文克劳', icon: '🦅', colors: { dark: 'var(--ravenclaw-dark)', light: 'var(--ravenclaw-light)' } }, hufflepuff: { name: '赫奇帕奇', icon: '🦡', colors: { dark: 'var(--hufflepuff-dark)', light: 'var(--hufflepuff-light)' } }, hogwarts: { name: '霍格沃茨', icon: '🏰', colors: { dark: '#4a4a4a', light: '#888888'} }, };
        let state = {};
        async function loadDataFromDB() {
            try {
                await db.open();
                console.log("数据库已成功打开。");
                const [appState, userProfile, apiConfig, contacts, chats, myMoments, friendMoments, groups, triwizardChapters] = await Promise.all([
                    db.appState.get('main'),
                    db.userProfile.get('main'),
                    db.apiConfig.get('main'),
                    db.contacts.toArray(),
                    db.chats.toArray(), 
                    db.myMoments.toArray(),
                    db.friendMoments.toArray(),
                    db.groups.toArray(),
                    db.triwizardChapters.toArray()
                ]);
                
                state = {
                    appInitialized: appState ? appState.initialized : false,
                    currentView: appState ? appState.currentView : 'messages',
                    userProfile: userProfile || { customEmojis: {} },
                    apiConfig: apiConfig || { provider: 'Google', url: '', key: '', model: '' },
                    chats: chats || [], 
                    contacts: contacts || [],
                    groups: groups || [],
                    myMoments: myMoments || [],
                    friendMoments: friendMoments || [],
                    triwizardChapters: triwizardChapters || [],
                    activeContactId: appState ? appState.activeContactId : null,
                    previousView: appState ? appState.previousView : null,
                    replyingTo: appState ? appState.replyingTo : null
                };
                return state.appInitialized;
            } catch (error) {
                console.error("数据库初始化或加载失败:", error);
                alert(`严重错误：无法初始化本地存储。您的数据可能无法保存。\n错误详情: ${error.stack}\n请尝试清除浏览器缓存后重试。`);
                return false;
            }
        }
        async function updateAppState() {
            state.appInitialized = true;
            await db.appState.put({
                id: 'main',
                initialized: state.appInitialized,
                currentView: state.currentView,
                activeContactId: state.activeContactId,
                previousView: state.previousView,
                replyingTo: state.replyingTo
            });
        }
        let viewContent, navItems, viewTitle, backButton, wizardDialog, dialogContent, navigation;
        function queryDOMElements() { viewContent = document.getElementById('viewContent'); navItems = document.querySelectorAll('.nav-item'); viewTitle = document.getElementById('viewTitle'); backButton = document.getElementById('backButton'); wizardDialog = document.getElementById('wizardDialog'); dialogContent = document.getElementById('dialogContent'); navigation = document.querySelector('.navigation'); }
        
        async function initializeDefaultData(playerHouse) {
            const d = getDefaultContacts();
            const allHouses = ['slytherin', 'gryffindor', 'ravenclaw', 'hufflepuff'];
            const otherHouses = allHouses.filter(h => h !== playerHouse);
        
            const contacts = [
                ...d.professors,
                ...d[playerHouse],
                ...otherHouses.flatMap(h => d[h]),
                { id: '原创角色1', name: "原创角色1", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null },
                { id: '原创角色2', name: "原创角色2", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null },
                { id: '原创角色3', name: "原创角色3", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null },
                { id: '原创角色4', name: "原创角色4", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null },
                { id: '原创角色5', name: "原创角色5", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null },
                { id: '原创角色6', name: "原创角色6", house: 'hogwarts', oc: true, icon: '👤', info: "", sharedHistory: "", avatar: null }
            ];
            contacts.forEach(c => c.isPinned = false);
            state.contacts = contacts;
            await db.contacts.bulkPut(contacts);
        
            const defaultGroups = [
                { id: 'group_professors', name: '教授', contactIds: d.professors.map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false },
                { id: `group_${playerHouse}`, name: HOUSE_INFO[playerHouse].name, contactIds: d[playerHouse].map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false },
                { id: 'group_other_houses', name: '其他学院', contactIds: otherHouses.flatMap(h => d[h].map(c => c.id)), isDeletable: true, isRenamable: true, isPinned: false },
                { id: 'group_oc', name: '原创角色', contactIds: contacts.filter(c => c.oc).map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false }
            ];
            state.groups = defaultGroups;
            await db.groups.bulkPut(defaultGroups);
        
            await initializeDefaultGroups(playerHouse);
            await initializeTriwizardChapters(playerHouse);
        }
        function applyHouseTheme(house) { if(!house) return; const r = document.documentElement; const c = HOUSE_INFO[house].colors; r.style.setProperty('--theme-dark', c.dark); r.style.setProperty('--theme-light', c.light); }
        
        async function switchView(view, skipHistory = false) { 
            if (!skipHistory) state.previousView = state.currentView; 
            state.currentView = view; 
            const complexViews = ['chat', 'newMoment', 'editFriend', 'triwizard']; 
            if (!complexViews.includes(view)) { 
                navItems.forEach(item => item.classList.toggle('active', item.dataset.view === view)); 
            } 
            backButton.classList.toggle('hidden', !complexViews.includes(view)); 
            if (navigation) navigation.classList.toggle('hidden', view === 'chat'); 
            viewContent.innerHTML = window[`generate${view.charAt(0).toUpperCase() + view.slice(1)}View`](); 
            window[`bind${view.charAt(0).toUpperCase() + view.slice(1)}Events`](); 
            const titles = { messages: '消息', contacts: '联系人', moments: '魔法动态', profile: '我的主页', newMoment: '发布动态', triwizard: '三强争霸赛' }; 
            if(titles[view]) viewTitle.textContent = titles[view]; 
            await updateAppState();
        }
        function showDialog(content, maxWidth = '500px') { dialogContent.style.maxWidth = maxWidth; dialogContent.innerHTML = `<button class="close-dialog-btn">&times;</button>${content}`; wizardDialog.classList.remove('hidden'); wizardDialog.querySelector('.close-dialog-btn').onclick = hideDialog; wizardDialog.onclick = (e) => { if (e.target === wizardDialog) hideDialog(); };}
        function hideDialog() { wizardDialog.classList.add('hidden'); dialogContent.style.maxWidth = '500px'; }
        function handleAvatarUpload(event, callback) { const file = event.target.files[0]; if (!file || !file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (e) => callback(e.target.result); reader.readAsDataURL(file); }
        function getAvatarStyle(avatarUrl, color) { return avatarUrl ? `background-image: url(${avatarUrl})` : `background-color: ${color}`; }
        async function applyCustomFont(url, family) {
            const existingLink = document.getElementById('custom-font-stylesheet');
            if (existingLink) existingLink.remove();
            state.userProfile.fontUrl = url;
            state.userProfile.fontFamily = family;
            await db.userProfile.put({id: 'main', ...state.userProfile});
            const applyFamily = () => {
                const finalFamily = family || `'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
                document.documentElement.style.setProperty('--main-font', finalFamily);
            };
            if (url) {
                const link = document.createElement('link');
                link.id = 'custom-font-stylesheet';
                link.rel = 'stylesheet';
                link.href = url;
                link.onload = applyFamily;
                link.onerror = () => {
                    console.error('Failed to load custom font stylesheet.');
                    alert('自定义字体样式表加载失败，请检查URL是否正确。');
                    applyFamily(); 
                };
                document.head.appendChild(link);
            } else {
                applyFamily();
            }
        }
        window.generateMessagesView = function() {
            const visibleChats = (state.chats || []).filter(chat => !chat.isHidden);
            const header = `<button class="btn primary" id="startTriwizardBtn" style="width:100%; margin-bottom: 20px; background: linear-gradient(to right, #d3a625, #f0e6d2); color: #111418; text-shadow: none;"><i class="fas fa-trophy"></i> 点击参加三强争霸赛</button>`;
            if (visibleChats.length === 0) return header + `<div class="card">还没有消息。去联系人列表里找人聊聊吧！</div>`;
            
            let html = header + '<div class="view-title"><i class="fas fa-comments"></i> 魔法消息</div><div class="chat-list">';
            const sortedChats = [...visibleChats].sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));
            sortedChats.forEach(chat => {
                const contact = chat.isGroup ? null : state.contacts.find(c => c.id === chat.contactId);
                const house = chat.isGroup ? state.userProfile.house : (contact ? contact.house : 'hogwarts');
                const colors = HOUSE_INFO[house].colors;
                const pinIcon = chat.isPinned ? '<i class="fas fa-thumbtack" style="color: var(--theme-accent); position: absolute; top: 12px; right: 12px; font-size: 12px;"></i>' : '';
                
                const isGroupWithAvatar = chat.isGroup && chat.avatar;
                const avatarContent = isGroupWithAvatar ? '' : (chat.isGroup ? '👥' : (contact && !contact.avatar ? contact.icon || '👤' : ''));
                const avatarStyle = isGroupWithAvatar ? getAvatarStyle(chat.avatar, colors.dark) : (chat.isGroup ? `background-color: ${colors.dark}` : getAvatarStyle(contact?.avatar, colors.dark));
                
                html += `<div class="chat-item" data-chat-id="${chat.id}">
                            <div class="chat-avatar avatar" style="${avatarStyle}">${avatarContent}</div>
                            <div class="chat-content">
                                <div class="chat-header"><div>${chat.name}</div><div>${chat.time}</div></div>
                                <div>${chat.lastMessage}</div>
                            </div>
                            ${pinIcon}
                         </div>`;
            });
            return html + '</div>';
        }
        window.generateContactsView = function() {
            return `
                <div class="tabs">
                    <div class="tab active" data-tab="friends">好友</div>
                    <div class="tab" data-tab="groups">群聊</div>
                </div>
                <div id="contactsContent"></div>
            `;
        }
        
        function renderGroupedContacts() {
            const contactsContent = document.getElementById('contactsContent');
            if (!contactsContent) return;
        
            let html = `<button class="btn primary" id="manageGroupsBtn" style="width:100%;"><i class="fas fa-edit"></i> 管理分组</button><div id="groupsContainer">`;
            const allContactIdsInGroups = new Set(state.groups.flatMap(g => g.contactIds));
        
            const sortedGroups = [...state.groups].sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));
        
            for (const group of sortedGroups) {
                html += `<div class="group-wrapper" data-group-id="${group.id}">
                            <div class="group-header">
                                <h3 class="group-name">${group.name}</h3>
                            </div>
                            <div class="friends-list">`;
                const members = state.contacts.filter(c => group.contactIds.includes(c.id));
                members.sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));
                if (members.length > 0) {
                    members.forEach(contact => {
                         const house = contact.house || 'hogwarts';
                         const colors = HOUSE_INFO[house].colors;
                         const pinIcon = contact.isPinned ? '<i class="fas fa-thumbtack" style="color: var(--theme-accent); position: absolute; top: 10px; right: 10px; font-size: 12px;"></i>' : '';
                         html += `<div class="friend-item" data-contact-id="${contact.id}">
                                     ${pinIcon}
                                     <div class="friend-avatar avatar" style="${getAvatarStyle(contact.avatar, colors.dark)}; border-color: ${colors.light};">${!contact.avatar ? contact.icon || '👤' : ''}</div>
                                     <div class="friend-name">${contact.name}</div>
                                  </div>`;
                    });
                } else {
                    html += `<p style="opacity: 0.6; padding: 10px 15px;">该分组为空</p>`;
                }
                html += `</div></div>`;
            }
        
            const ungroupedContacts = state.contacts.filter(contact => !allContactIdsInGroups.has(contact.id));
            ungroupedContacts.sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));
            if (ungroupedContacts.length > 0) {
                html += `<div class="group-wrapper" data-group-id="ungrouped">
                            <div class="group-header"><h3 class="group-name">未分组</h3></div>
                            <div class="friends-list">`;
                ungroupedContacts.forEach(contact => {
                    const house = contact.house || 'hogwarts';
                    const colors = HOUSE_INFO[house].colors;
                    const pinIcon = contact.isPinned ? '<i class="fas fa-thumbtack" style="color: var(--theme-accent); position: absolute; top: 10px; right: 10px; font-size: 12px;"></i>' : '';
                    html += `<div class="friend-item" data-contact-id="${contact.id}">
                                 ${pinIcon}
                                 <div class="friend-avatar avatar" style="${getAvatarStyle(contact.avatar, colors.dark)}; border-color: ${colors.light};">${!contact.avatar ? contact.icon || '👤' : ''}</div>
                                 <div class="friend-name">${contact.name}</div>
                              </div>`;
                });
                html += `</div></div>`;
            }
        
            html += `</div>`;
            contactsContent.innerHTML = html;
            bindFriendItemEvents();
            bindFriendsTabEvents();
        }
        function renderGroupsList() {
            const contactsContent = document.getElementById('contactsContent');
            if (!contactsContent) return;
            let html = `<button class="btn primary" id="createGroupBtn" style="width:100%; margin-bottom: 15px;"><i class="fas fa-users"></i> 创建群聊</button><div class="chat-list">`;
            const groupChats = state.chats.filter(c => c.isGroup).sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));;
            if(groupChats.length === 0) {
                 html += `<div class="card">还没有群聊，快创建一个吧！</div>`;
            } else {
                groupChats.forEach(chat => {
                    const house = state.userProfile.house;
                    const colors = HOUSE_INFO[house].colors;
                    const pinIcon = chat.isPinned ? '<i class="fas fa-thumbtack" style="color: var(--theme-accent); position: absolute; top: 12px; right: 12px; font-size: 12px;"></i>' : '';
                    const avatarContent = chat.avatar ? '' : '👥';
                    const avatarStyle = getAvatarStyle(chat.avatar, colors.dark);
                    html += `<div class="chat-item" data-chat-id="${chat.id}">
                                <div class="chat-avatar avatar" style="${avatarStyle}">${avatarContent}</div>
                                <div class="chat-content">
                                    <div class="chat-header"><div>${chat.name}</div><div>${chat.members.length}人</div></div>
                                </div>
                                ${pinIcon}
                            </div>`;
                });
            }
            contactsContent.innerHTML = html + '</div>';
            document.getElementById('createGroupBtn').addEventListener('click', showGroupCreationDialog);
            contactsContent.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('click', function() {
                    state.currentChat = state.chats.find(c => c.id === this.dataset.chatId);
                    if(state.currentChat) switchView('chat');
                });
                addLongPressListener(item, (e) => {
                    e.preventDefault();
                    showContextMenu(e, 'groupChatItem', item.dataset.chatId);
                });
            });
        }
        
        window.generateProfileView = function() {
            const p = state.userProfile;
            const houseName = HOUSE_INFO[p.house].name;
            return `<div class="card"><div class="profile-header"><label for="profileAvatarUpload"><div class="profile-avatar avatar" style="${getAvatarStyle(p.avatar, '#2c3e50')}"></div></label><input type="file" id="profileAvatarUpload" class="hidden" accept="image/*"><div class="profile-details"><div class="profile-name" title="点击修改姓名">${p.name}<span class="house-badge" style="background-color: var(--theme-light);">${houseName}</span></div><div>血统: ${p.blood}</div><div class="editable" data-key="signature" title="点击修改">${p.signature}</div></div></div></div><div class="card"><h3><i class="fas fa-id-card"></i> 巫师档案</h3><div class="info-grid"><span class="info-label">学院：</span><span>${houseName} ${HOUSE_INFO[p.house].icon}</span><span class="info-label">年龄：</span><span class="info-value editable" data-key="age" title="点击修改">${p.age || '未知'}</span><span class="info-label">魔杖：</span><span class="info-value editable" data-parent-key="wand" data-key="wood" title="点击修改木材">${p.wand.wood}</span><span class="info-label"></span><span class="info-value editable" data-parent-key="wand" data-key="core" title="点击修改杖芯">${p.wand.core}</span><span class="info-label"></span><span class="info-value editable" data-parent-key="wand" data-key="length" title="点击修改长度">${p.wand.length}</span><span class="info-label"></span><span class="info-value editable" data-parent-key="wand" data-key="flex" title="点击修改柔韧度">${p.wand.flex}</span><span class="info-label">守护神：</span><span class="info-value editable" data-key="patronus" title="点击修改">${p.patronus}</span><span class="info-label">宠物：</span><span class="info-value editable" data-key="pet" title="点击修改">${p.pet}</span><span class="info-label">外貌：</span><span class="info-value editable" data-key="appearance" title="点击修改">${p.appearance}</span><span class="info-label">性格：</span><span class="info-value editable" data-key="personality" title="点击修改">${p.personality}</span></div></div><div class="card"><h3><i class="fas fa-robot"></i> 对话API设置</h3><div class="form-group"><label>API厂家</label><input type="text" id="apiProvider" value="${state.apiConfig.provider || ''}" placeholder="例如: Google, OpenAI, Groq"></div><div class="form-group"><label>API URL (无需添加 /v1/chat/completions)</label><input type="text" id="apiUrl" value="${state.apiConfig.url || ''}" placeholder="例如: https://api.openai.com"></div><div class="form-group"><label>API 密钥</label><input type="password" id="apiKey" value="${state.apiConfig.key || ''}" placeholder="输入你的API Key"></div><div class="form-group"><label>模型名称</label><div class="model-group"><select id="apiModelSelect"><option value="">请先获取模型列表</option></select><button class="btn primary" id="fetchModelsBtn" style="padding: 8px 12px; font-size: 14px; flex-shrink: 0;">获取模型</button></div></div><button class="btn primary" id="testApiBtn" style="margin-top:10px;">测试连接</button><button class="btn primary" id="saveApiConfig" style="margin-top: 15px;"><i class="fas fa-save"></i> 保存设置</button></div><div class="card"><h3><i class="fas fa-paint-brush"></i> 外观设置</h3><div class="form-group"><label>字体CSS URL</label><input type="text" id="fontUrlInput" value="${p.fontUrl || ''}" placeholder="输入.css格式的字体链接"></div><div class="form-group"><label>字体族名 (Font Family)</label><input type="text" id="fontFamilyInput" value="${p.fontFamily || ''}" placeholder="例如: 'Noto Sans SC', sans-serif"></div><button class="btn primary" id="applyFontBtn" style="margin-top: 10px;">应用字体</button></div><div class="card"><h3><i class="fas fa-cog"></i> 账号设置</h3><button class="btn logout" id="logoutBtn"><i class="fas fa-sign-out-alt"></i> 删除数据并重启</button></div><div class="card"><h3><i class="fas fa-database"></i> 数据管理</h3><button class="btn primary" id="exportDataBtn"><i class="fas fa-file-export"></i> 导出全部数据</button><button class="btn primary" id="importDataBtn"><i class="fas fa-file-import"></i> 导入全部数据</button><input type="file" id="importDataInput" class="hidden" accept=".json,application/json,text/plain"></div>`;
        }
        window.generateChatView = function() {
            viewTitle.textContent = state.currentChat.name;
            const isGroupChat = state.currentChat.isGroup;
            const isTriwizard = state.currentChat.isTriwizard;
            const historyHtml = (state.currentChat.messages || []).map(msg => {
                let content;
                switch(msg.type) {
                    case 'image': content = `<div class="message-text">${msg.text}</div><img src="${msg.imageData}" class="message-image">`; break;
                    case 'emoji': content = `<img src="${msg.url}" class="message-emoji" alt="${msg.name}">`; break;
                    case 'gift': 
                        const giftImageHtml = msg.gift.image ? `<img src="${msg.gift.image}" class="gift-image">` : `<div class="gift-image-default">🎁</div>`;
                        const recipientText = msg.gift.recipient ? ` to <strong>${msg.gift.recipient}</strong>` : '';
                        content = `<div class="gift-card">${giftImageHtml}<div class="gift-details"><div class="gift-title">${msg.gift.name}${recipientText}</div><div class="gift-message">${msg.gift.message}</div><div class="gift-price">¥${msg.gift.price}</div></div></div>`; 
                        break;
                    default: content = `${msg.quote ? `<div class="message-quote"><strong>${msg.quote.sender}:</strong> ${msg.quote.text}</div>` : ''}<div class="message-text">${msg.text}</div>`;
                }
                
                let senderHtml = '';
                if (isTriwizard && msg.incoming) {
                    senderHtml = `<div class="message-sender">${msg.sender || '旁白'}</div>`;
                }
                else if (isGroupChat && msg.incoming) {
                    senderHtml = `<div class="message-sender">${msg.sender}</div>`;
                } else if ((isGroupChat || isTriwizard) && !msg.incoming) {
                    const myNickname = state.currentChat.myNickname || state.userProfile.name;
                    senderHtml = `<div class="message-sender" style="text-align: right;">${myNickname}</div>`;
                }
                return `<div class="message ${msg.incoming ? 'incoming' : 'outgoing'}" data-message-id="${msg.id}">${senderHtml}${content}<span class="message-time">${msg.time}</span></div>`;
            }).join('');
            
            const groupSettingsButton = isGroupChat ? `<button class="action-btn" id="groupSettingsBtn" title="群聊设置"><i class="fas fa-users-cog"></i><span>群设置</span></button>` : '';
            const regularActions = `
                <button class="action-btn" id="searchChatBtn" title="搜索记录"><i class="fas fa-search"></i><span>搜索</span></button>
                <button class="action-btn" id="aiInitiateMessageBtn" title="AI发起对话"><i class="fas fa-magic"></i><span>AI回复</span></button>
                <button class="action-btn" id="offlineModeBtn" title="切换线下模式"><i class="fas fa-street-view"></i><span>线下模式</span></button>
                <button class="action-btn" id="emojiBtn" title="发送表情"><i class="fas fa-smile"></i><span>表情</span></button>
                <button class="action-btn" id="sendImageBtn" title="发送图片"><i class="fas fa-image"></i><span>图片</span></button>
                <button class="action-btn" id="memoryBtn" title="记忆"><i class="fas fa-brain"></i><span>记忆</span></button>
                <button class="action-btn" id="sendGiftBtn" title="赠送礼物"><i class="fas fa-gift"></i><span>礼物</span></button>
                <button class="action-btn" id="chatSettingsBtn" title="聊天设置"><i class="fas fa-cog"></i><span>设置</span></button>
                ${groupSettingsButton}
            `;
            const triwizardActions = `
                <button class="action-btn" id="searchChatBtn" title="搜索记录"><i class="fas fa-search"></i><span>搜索</span></button>
                <button class="action-btn" id="aiInitiateMessageBtn" title="剧情推进"><i class="fas fa-magic"></i><span>剧情推进</span></button>
                <button class="action-btn" id="saveStoryBtn" title="保存记录"><i class="fas fa-save"></i><span>保存记录</span></button>
            `;
            return `<div class="chat-window">
                        <div class="chat-history" id="chatHistory">${historyHtml}</div>
                        <div class="chat-input-area">
                            <div class="chat-input-row">
                                <div class="chat-input"><input type="text" id="messageInput" placeholder="输入消息..." autocomplete="off"></div>
                                <button class="send-btn" id="sendMessageBtn">发送</button>
                            </div>
                            <div class="chat-actions-grid">
                                ${isTriwizard ? triwizardActions : regularActions}
                            </div>
                            <div class="emoji-panel" id="emojiPanel">
                                <div class="emoji-panel-header">
                                    <h3>表情包</h3>
                                    <div>
                                        <button class="btn primary" id="addEmojiBtn" style="padding: 5px 10px; font-size: 12px;">添加</button>
                                        <button class="btn logout" id="deleteEmojiBtn" style="padding: 5px 10px; font-size: 12px;">删除</button>
                                    </div>
                                </div>
                                <div class="emoji-grid" id="emojiGrid"></div>
                            </div>
                        </div>
                    </div>`;
        }
        window.generateMomentsView = function() { return `<div class="tabs"><div class="tab active" data-tab="friends">好友动态</div><div class="tab" data-tab="mine">我的动态</div></div><div id="momentsContent"></div>`; }
        window.generateNewMomentView = function() { 
            return `<div class="card"><h3><i class="fas fa-feather"></i> 分享魔法时刻</h3><div class="form-group"><label>动态内容</label><textarea id="momentContent" placeholder="..."></textarea></div><div class="form-group"><label>附加图片</label><input type="file" id="momentImageUpload" accept="image/*"><img id="momentImagePreview" class="image-preview hidden"></div><div class="form-group"><label>可见范围</label><button class="btn primary" id="momentVisibilityBtn" style="justify-content: flex-start;">公开</button></div><div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;"><button class="btn logout" id="cancelMoment">取消</button><button class="btn primary" id="publishMoment"><i class="fas fa-paper-plane"></i> 发布</button></div></div>`; 
        }
        window.generateEditFriendView = function() { const c = state.contacts.find(c => c.id === state.activeContactId); viewTitle.textContent = `编辑 - ${c.name}`; return `<div class="card"><div style="text-align: center; margin-bottom: 20px;"><label for="friendAvatarUpload"><div class="friend-avatar avatar" style="${getAvatarStyle(c.avatar, HOUSE_INFO[c.house].colors.dark)}; margin: 0 auto 10px;">${!c.avatar ? c.icon : ''}</div></label><input type="file" id="friendAvatarUpload" class="hidden" accept="image/*"></div><div class="tabs"><div class="tab active" data-tab="info">好友信息</div><div class="tab" data-tab="history">共同经历</div></div><div id="tabContent">${c.oc ? `<div class="form-group"><label>角色ID</label><input type="text" id="friendId" value="${c.id}"></div>` : ''}<div class="form-group"><label>基本信息</label><textarea id="friendInfo" rows="6">${c.info}</textarea></div></div><button class="btn primary" id="saveFriendInfoBtn" style="width: 100%; margin-top: 20px;"><i class="fas fa-save"></i> 保存</button></div>`; }
        window.generateTriwizardView = function() {
            const chapters = [
                { id: 'twt_chap1', name: '一：勇士选拔' },
                { id: 'twt_chap2', name: '二：休息室的夜晚' },
                { id: 'twt_chap3', name: '三：夜探火龙' },
                { id: 'twt_chap4', name: '四：挑战火龙' },
                { id: 'twt_chap5', name: '五：圣诞舞会的前奏' },
                { id: 'twt_chap6', name: '六：圣诞舞会之夜' },
                { id: 'twt_chap7', name: '七：深湖的考验' },
                { id: 'twt_chap8', name: '八：迷宫的终点' },
                { id: 'twt_chap9', name: '九：墓地的宿命' }
            ];
            let html = '<div class="twt-button-list">';
            chapters.forEach(chap => {
                html += `<button class="twt-button" data-chapter-id="${chap.id}">${chap.name}</button>`;
            });
            return html + '</div>';
        }
        async function initializeDefaultGroups(playerHouse) {
            const d = getDefaultContacts();
            const allStudents = [...d.slytherin, ...d.gryffindor, ...d.ravenclaw, ...d.hufflepuff];
            
            const dumbledore = {
                id: 'virtual_dumbledore',
                name: '阿不思·邓布利多',
                nickname: '邓布利多校长',
                persona: '霍格沃茨校长，睿智、强大且偶尔有些古怪，关心着每一个学生。',
                sharedHistory: '作为校长，他一直默默关注着你的成长。'
            };
            
            const allContacts = [...d.professors, ...allStudents].filter(c => !c.oc);
            const hogwartsMembers = allContacts.map(c => ({
                id: c.id, name: c.name, nickname: null, persona: c.info, sharedHistory: c.sharedHistory
            }));
            hogwartsMembers.push(dumbledore);
            const hogwartsGroup = {
                id: 'group_hogwarts_default',
                name: '霍格沃茨群',
                isGroup: true,
                members: hogwartsMembers,
                contactId: null,
                lastMessage: '欢迎来到霍格沃茨！',
                time: new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
                messages: [{
                    id: `msg_${Date.now()}`, type: 'text', text: '欢迎来到霍格沃茨！在这里你可以和所有的教授、同学交流。',
                    time: new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
                    incoming: true, sender: '阿不思·邓布利多'
                }],
                background: null, isPinned: false, summary: "霍格沃茨全体师生的交流群。", isHidden: false, isOfflineMode: false, avatar: null, myNickname: null
            };
            
            const houseMembers = d[playerHouse].map(c => ({
                id: c.id, name: c.name, nickname: null, persona: c.info, sharedHistory: c.sharedHistory
            }));
            const houseGroupName = `${HOUSE_INFO[playerHouse].name}学院群`;
            const houseGroup = {
                id: `group_${playerHouse}_default`,
                name: houseGroupName,
                isGroup: true,
                members: houseMembers,
                contactId: null,
                lastMessage: '欢迎来到你的学院！',
                time: new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
                messages: [{
                    id: `msg_${Date.now() + 1}`, type: 'text', text: `欢迎所有新生来到${HOUSE_INFO[playerHouse].name}！这里是我们的专属交流地。`,
                    time: new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
                    incoming: true, sender: '级长' 
                }],
                background: null, isPinned: false, summary: `专属于${HOUSE_INFO[playerHouse].name}学院的内部交流群。`, isHidden: false, isOfflineMode: false, avatar: null, myNickname: null
            };
            await db.chats.bulkPut([hogwartsGroup, houseGroup]);
            state.chats = await db.chats.toArray();
        }
        function generateDefaultTriwizardChapters(playerHouse) {
             const intros = {
                twt_chap1: '万圣节的晚宴总是霍格沃茨一年中最盛大的庆典之一，但今晚，空气中弥漫的与其说是节日的欢愉，不如说是一种近乎沸腾的期待。\n南瓜灯的烛火在每一张年轻的脸上跳跃，映照出他们紧张而兴奋的神情。邓布利多站在主宾席前，他深邃的蓝眼睛似乎能穿透每一个学生的内心。\n随着他的宣告，火焰杯——那只古老、布满符文且散发着幽蓝色光芒的魔法器物——终于要揭晓它的选择了。德姆斯特朗的威克多尔·克鲁姆，布斯巴顿的芙蓉·德拉库尔，以及霍格沃茨的塞德里克·迪戈里，三个名字被火焰依次吐出，每一次都伴随着雷鸣般的掌声与欢呼。\n然而，当所有人都以为尘埃落定时，火焰杯的蓝色火焰却猛地再次窜高，变成了不祥的红色。一张烧焦的羊皮纸被喷射出来，邓布利多下意识地抓住它，念出了那个让整个礼堂陷入死寂的名字：“哈利·波特”。\n骚动、质疑与愤怒如同瘟疫般蔓延开来。就在这混乱的顶点，在你几乎要因周围的喧嚣以为这一切不过是一场荒唐的闹剧时，那该死的火焰杯，居然又一次吐出了一张字条。\n邓布利多的声音第三次响彻礼堂，而这一次，他念出的，是你的名字。',
                twt_chap2: {
                    gryffindor: '你头疼地听着主办方们的争论，什么都没听进去，只知道迫于火焰杯选中的勇士必须参赛的规矩，你和哈利最终仍然成为了三强争霸赛的第四、第五名勇士。\n你几乎不记得自己是如何穿过那些充满审视、怀疑、嫉妒与困惑的眼神，回到公共休息室的——是的，连门口的胖夫人也开始八卦你和哈利这两个“刚被选中的勇士”。\n哈利的情绪还算稳定，或许是因为你们两人共同受难在他眼里总好过他一个人倒霉。\n肖像画打开时，突然灌进耳朵的喧哗声震得你们差点儿仰面摔倒。接着，你们俩被大约十几双手拽进了公共休息室，面对着格兰芬多学院的全体同学。他们全都在尖叫、欢呼、吹口哨。\n“你们应该告诉我们你们报了名！”弗雷德大声吼道。他看上去半是恼怒、半是激动。\n“你们怎么能不长胡子就顺利过关了？”乔治嚷嚷道。\n安吉利娜旋风般地冲到你们面前，“哦，即使不可能是我，至少也是格兰芬多的一员啊——啊不，是两位！”\n“我们准备了吃的东西，你们快过来吃点儿——”\n没有人愿意听你们说你们没有把名字投进高脚杯，似乎谁也没有注意到你们根本就没有情绪庆祝这件事……你们没有办法脱身，每当你们想偷偷溜向通往宿舍的楼梯时，人群就向你们靠拢，把你们团团围住，强迫着再喝一杯黄油啤酒，或把饼干和花生硬塞进你们手里……每个人都想知道你们是怎么办成的，你们是怎么骗过邓布利多的年龄线，把名字投进高脚杯的……\n不知狂欢了多久，人群逐渐散去，你和哈利拖着疲惫的身体准备回到寝室，却看见角落里的一个格兰芬多学生向你们招手。\n“嘿，两位！我或许知道你们的名字是怎么被扔进去的！”那小孩看上去并不大，但一副要分享一个巨大秘密的模样着实让你们心下一动。\n“听着，前些天，大半夜的时候，我看见有个拉文克劳的高年级学生，背了那——么多的纸条，”那个学生夸张地张大双臂，“跨进年龄线后一股脑子都扔进了火焰杯里面！他的手上还在做记录！我捡了一张漏出来的纸条，上面就是个人名！我猜又是个想测试火焰杯机制的拉文克劳。”\n你和哈利面面相觑，心里却已经信了几分。\n一场让你们无法拒绝参加的可能丧命的比赛，原来是个做研究的拉文克劳干的，真他妈的合理，真他妈的漂亮。',
                    slytherin: '你头疼地听着主办方们的争论，什么都没听进去。最终，在“契约魔法不可违背”的古老规则下，你和哈利·波特成为了这场闹剧里多出来的两个小丑。\n回地窖的路上，你感受到的不是格兰芬多式的喧闹，而是一种更为冰冷、更为尖锐的沉默。每一个与你擦肩而过的斯莱特林学生，眼神中都带着毫不掩饰的审视与评估。\n通往公共休息室的口令仿佛是一个分界线，当你踏入那片被湖水映成幽绿色的空间时，你立刻成为了所有目光的焦点。这里没有欢呼，没有庆祝，只有壁炉里燃烧的火焰发出噼啪的声响，以及德拉科·马尔福那标志性的、拖长了的嘲讽声调：“哦，看看谁回来了？我们伟大的、出人意料的勇士。真没想到，我们学院竟然有人会用如此……‘格兰芬多式’的鲁莽方式去追求荣誉，甚至不惜和那个圣人波特一起分享风头。”\n他的话引来了一阵压抑的窃笑。潘西·帕金森靠在他的身边，用一种打量货物的眼神看着你：“瞒过邓布利多的年龄线，这手法倒还算聪明。但你图什么呢？让斯莱特林的荣耀与一个波特并列？还是说，你根本就是个彻头彻尾的蠢货，被人利用了？”周围没有人为你辩解，他们只是冷眼旁观，似乎在等待你给出一个能让他们信服的、符合斯莱特林利益的解释。\n这时，一个平日里并不起眼的同级生悄悄凑到你身边，用只有你们两人能听到的声音说：“别理他们，回复只会让他们觉得你更愚蠢。不过……我可能知道这是怎么回事。前几天晚上，我看到一个拉文克劳的疯子往火焰杯里扔了一大堆名字，像是在测试火焰杯的什么魔法极限。我猜，你只是他那个愚蠢实验里最倒霉的样本。别让他们知道，否则你会从‘愚蠢的追名者’变成‘被拉文克劳耍了的傻瓜’，那更糟。”',
                    ravenclaw: '你头疼地听着主办方们的争论，最终在魔法契约的约束下，你和哈利·波特成为了这场比赛中两个最不合逻辑的变量。\n当你怀着复杂的心情回到拉文克劳公共休息室时，迎接你的既不是热烈的庆祝，也不是冰冷的审视，而是一种……近乎狂热的学术探究氛围。\n你一踏入休息室，立刻被一群同学围得水泄不通，他们手里甚至还拿着笔记本和羽毛笔。“你是怎么做到的？”一个级长推了推眼镜，眼神里闪烁着求知的光芒，“邓布利多的年龄线是一种非常高深的魔法，我们推算了十七种破解方法，但都存在悖论。你用的混淆咒吗？还是某种罕见的炼金术物品？”“火焰杯的选择机制到底是什么？”另一个女生急切地问，“它的辨识核心是基于意愿强度，还是单纯的魔法签名？你的名字被选中，是否意味着投入多个名字会干扰它的判断逻辑？”\n他们的问题一个接一个，仿佛你不是去参加一场危险的比赛，而是刚刚攻克了一道悬赏多年的学术难题。你被这股求知欲的浪潮淹没，百口莫辩。\n就在这时，人群外传来一个带着歉意的声音：“那个……各位，请让我进去一下。”\n一个高年级的学生挤了进来，他脸色苍白，看上去比你还要紧张。他走到你面前，深深地鞠了一躬：“对不起！真的非常对不起！那是我干的！”\n在众人惊讶的目光中，他结结巴巴地解释道：“我只是想研究火焰杯的响应机制和混淆咒的边界效应……我往里面投了十几个随机的名字做样本……我发誓我没想到真的会选中一个！我……我愿意向邓布利多教授解释一切！”你看着眼前这个几乎要哭出来的“罪魁祸首”，一时间竟不知道是该生气还是该觉得荒谬。原来，你之所以身陷囹圄，竟真的是因为一场该死的学术实验。',
                    hufflepuff: '你头疼地听着主办方们的争论，当邓布利多最终宣布，迫于魔法契约，你和哈利也必须参赛时，你感到一阵眩晕。\n然而，当你拖着沉重的步伐，和塞德里克·迪戈里一起回到赫奇帕奇的公共休息室时，所有的不安和焦虑都被一股温暖的浪潮所吞没。\n通往休息室的木桶通道里就已经传出了欢快的声音，你们一进去，立刻被快乐的黄色与黑色所包围。同学们举着塞德里克和你名字的横幅，热情地拥抱你们，将你们俩高高地举到空中抛起来。“我们有两个勇士！赫奇帕奇有两个勇士！”他们欢呼着，兴奋得满脸通红。\n厨房里的家养小精灵们送来了堆积如山的蛋糕、馅饼和南瓜汁，整个休息室变成了一场盛大的派对。塞德里克看上去也为你感到高兴，他拍着你的肩膀说：“真没想到！但太棒了，不是吗？我们一起为赫奇帕奇争光！”\n当然，也有几个同学凑到你身边，好奇地小声问：“说真的，你是怎么做到的？你看起来不像会用黑魔法作弊的样子啊……”但他们话还没说完，旁边立刻就有人用胳膊肘捅了他们一下，或者拍了拍他们的后脑勺，低声斥责道：“嘿！别问这个！不管是怎么做到的，他们现在都是我们的勇士，我们支持就对了！”那种无条件的接纳和信任让你深受感动。\n在这片欢乐的海洋中，一个平日里关系不错的朋友凑到你耳边，分享了一个小秘密：“悄悄告诉你，我前几天看到一个拉文克劳的学长，在火焰杯前面神神叨叨的，往里面扔了一大把纸条，看上去真像是在做什么祈福仪式。说不定，你就是他给赫奇帕奇祈来的好运！”这番话让你哭笑不得，但心中最后的一丝阴霾，也在这温暖友好的氛围中悄然散去了。'
                },
                twt_chap3: '成为勇士所带来的短暂“荣耀”感很快便被现实的残酷所冲淡。在那个寒冷的夜晚，海格将你和哈利悄悄带到禁林边缘，你亲眼目睹了第一个项目的内容——火龙。那是纯粹的、来自远古的恐惧。五头体型庞大、脾气暴躁的成年火龙被关在临时的围栏里，每一次呼吸都喷出致命的烈焰，足以将岩石融化。它们嘶吼着，扇动着巨大的翅膀，守护着一窝金色的蛋，而你的任务，就是在全场的注视下，从这样一头暴怒的巨兽爪下，取走其中一颗。',
                twt_chap4: '比赛的号角终于在霍格沃茨上空吹响，那声音仿佛是对即将踏入战场的勇士的催命符。你站在通往龙穴的帐篷里，能清晰地听到外面山呼海啸般的欢呼和卢多·巴格曼用魔法放大的、过分激动的解说声。\n在此之前，你或许已经废寝忘食地查阅了无数关于龙的资料，向教授或朋友请教，练习了上百遍你认为可能奏效的咒语。但当帐篷的门帘被工作人员无情地拉开，刺眼的阳光和数千道目光同时聚焦在你身上时，所有的准备似乎都在一瞬间被抽空。\n​你迈着僵硬的步伐走进赛场，脚下的石子地被正午的太阳晒得滚烫。在场地的另一端，你的对手——那头来自喀尔巴阡山脉的罗马尼亚角龙，正盘踞在一窝金蛋之上。它的身躯比你想象的还要庞大，黑绿色的鳞片在阳光下折射出金属般冷硬的光泽，宛如覆盖着一层古老的青铜盔甲。然而，最令人心悸的，是它头顶上那对引以为傲的长犄角。那对犄角长而优美，呈现出一种炫目的金色，仿佛由纯金铸造而成，在阳光下金光闪烁。\n​它感受到了你的闯入，巨大的头颅缓缓转向你，琥珀色的竖瞳里全然是审视和敌意。它轻轻地用那对华丽的长角摩擦了一下地面，坚硬的岩石立刻被划出深深的沟壑，并发出了刺耳的声响——你在书上读到过，这是它的捕猎习惯，先用犄角将猎物抵死、撕裂，然后再用龙焰将其烤熟享用。一缕灰烟从它布满利齿的口鼻间喷出，带着硫磺和焦炭的气味，将你面前的空气灼烧得微微扭曲。观众的喧哗声仿佛远在天边，此刻，你的世界里只剩下你和这头沉默而致命的巨兽。它在等你，等你踏入它那对黄金长角的攻击范围。没有退路，没有援助，只有你和你手中的魔杖。深呼吸，稳住颤抖的手，这场生死对决，现在开始。',
                twt_chap5: '第一个项目的惊心动魄尚未完全平息，一个全新的、截然不同的挑战悄然而至——圣诞舞会。这是三强争霸赛的传统环节，旨在促进国际间的友谊。对于大多数学生来说，这是一场充满期待的盛大派对；但对于你——霍格沃茨的第五位，也是最出人意料的勇士——这意味着你必须找到一位舞伴，并作为开场舞的引领者之一，接受所有人的瞩目。一时间，寻找舞伴成了城堡里最热门的话题。走廊里、课堂上、公共休息室里，到处都是关于邀请与被邀的窃窃私语。你发现自己再次被推到了聚光灯下，一些人因为你的“勇士”身份而投来好奇或倾慕的目光，另一些人则依旧抱着看热闹的心态。你需要在人群中做出选择，是邀请你心仪已久的人，还是出于礼节选择一位朋友？与此同时，你还需要为自己准备一套得体的礼服。这意味着要去霍格莫德村的商店精心挑选，或是拜托家人从家里寄来。在这段看似轻松愉快的时光里，你暂时从致命的比赛中抽身，却陷入了另一种属于青春期的、甜蜜又烦恼的社交困境之中。',
                twt_chap6: '圣诞舞会当晚，霍格沃茨大礼堂被装点得如同一个仙境。天花板上洒下晶莹的雪花，却不会让人感到寒冷。墙壁上挂着闪闪发光的银色彩带，巨大的圣诞树上装饰着活生生的仙子。你穿着精心准备的礼服，与你的舞伴一起，和其他三位勇士及他们的舞伴站在大礼堂的门前，等待着入场。音乐响起，当沉重的橡木门缓缓打开，你踏入那片璀璨的灯海时，所有人的目光都集中在你们身上。作为勇士，你必须引领开场舞。在悠扬的华尔兹舞曲中，你和舞伴滑入舞池中央，每一个舞步都暴露在众目睽睽之下。这一刻，没有火龙，没有恶咒，只有旋转的舞步、闪烁的灯光和身边那个人的微笑。舞会的气氛热烈而欢快，怪姐妹乐队的摇滚乐点燃了全场的热情。这是一个可以暂时忘记比赛压力的夜晚，你可以与朋友们尽情欢笑，享受美食，甚至在某个安静的角落，与你的舞伴分享一些只属于你们的秘密。这是风暴来临前，难得的平静与美好。',
                twt_chap7: '第二个项目的神秘面纱终于揭晓，那颗从火龙爪下夺来的金蛋在水中发出了凄厉而清晰的歌声，指引着你们前往黑湖的深处。任务是：在一个小时内，从湖底救出你“最珍视的宝物”。\n当你得知所谓的“宝物”其实是你最亲近的朋友或家人时，比赛的性质瞬间改变了。这不再是单纯为了荣誉，而是为了拯救你所爱的人。\n冰冷刺骨的湖水在二月的寒风中翻涌着黑色的波浪，湖底潜藏着未知的危险——格林迪洛、水怪，以及默然注视着一切的人鱼部落。\n你必须找到一种方法，让你这个习惯了陆地生活的巫师，能够在水下呼吸和活动长达一个小时。时间紧迫，每一个决定都至关重要。\n加油吧，我的勇士，时间拨回到比赛开始的前一周，你的准备时间却已不算充裕。',
                twt_chap8: '经历了火龙的咆哮与黑湖的沉寂，三强争霸赛终于迎来了最后一个，也是最艰险的项目——迷宫。在魁地奇球场上，高耸的树篱一夜之间拔地而起，构成了一座巨大而复杂的迷宫。它的内部变幻莫测，充满了各种魔法障碍、神奇生物和迷惑人心的陷阱。邓布利多严肃地警告你们，迷宫会改变进入其中的人。你们将根据前两个项目的得分依次进入。\n目标只有一个：穿过重重险阻，最先触摸到位于迷宫中心的三强杯。当你踏入那条被阴影笼罩的狭窄通道，身后的入口缓缓关闭时，世界瞬间安静下来，只剩下你自己的心跳和风吹过树篱的沙沙声。你将独自面对未知的恐惧：会喷火的炸尾螺、颠倒你方向的魔法迷雾，以及可能比任何怪物都更危险的——其他同样渴望胜利的竞争者。',
                twt_chap9: '你几乎不敢相信自己的好运，这一路上出乎意料地没有遇到什么过分的阻碍，三强杯就在你的眼前，闪耀着胜利的光芒。哈利·波特几乎在同一时间也赶到了这里。或许是出于一路走来的惺惺相惜，你们决定一同举起奖杯，共享这份属于霍格沃茨的荣耀。\n然而，当你和哈利的手指触碰到冰冷的杯柄时，你感受到的并非胜利的喜悦，而是一阵剧烈的、令人作呕的拉扯感。周围的景色瞬间扭曲、旋转，你被一股无法抗拒的力量带离了霍格沃茨。双脚重重地落在一片阴冷潮湿的土地上，你发现自己身处一个荒凉的墓地，四周弥漫着死亡的气息。一个丑陋矮小的身影，正抱着一团虚弱而邪恶的东西，站在一座巨大的沸腾坩埚旁。\n哈利额头上的伤疤传来剧痛，他痛苦地倒在地上。你立刻意识到，这不是比赛的一部分，这是一个精心策划的陷阱。三强杯是一个门钥匙，大难不死的男孩是最后的祭品。而你——或许只是一个碍事的家伙。'
            };
            const chapters = [
                { id: 'twt_chap1', name: '一：勇士选拔', intro: intros.twt_chap1, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap2', name: '二：休息室的夜晚', intro: intros.twt_chap2[playerHouse], savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap3', name: '三：夜探火龙', intro: intros.twt_chap3, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap4', name: '四：挑战火龙', intro: intros.twt_chap4, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap5', name: '五：圣诞舞会的前奏', intro: intros.twt_chap5, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap6', name: '六：圣诞舞会之夜', intro: intros.twt_chap6, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap7', name: '七：深湖的考验', intro: intros.twt_chap7, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap8', name: '八：迷宫的终点', intro: intros.twt_chap8, savedSlots: [], mainSaveSlotIndex: -1 },
                { id: 'twt_chap9', name: '九：墓地的宿命', intro: intros.twt_chap9, savedSlots: [], mainSaveSlotIndex: -1 },
            ];
            return chapters;
        }
        async function initializeTriwizardChapters(playerHouse) {
            const chapters = generateDefaultTriwizardChapters(playerHouse);
            await db.triwizardChapters.bulkPut(chapters);
            state.triwizardChapters = chapters;
        }
        
        async function bindSetupEvents() { 
            document.getElementById('userHouse').addEventListener('change', (e) => applyHouseTheme(e.target.value)); 
            document.getElementById('startAdventureBtn').addEventListener('click', async () => { 
                const lastName = document.getElementById('userLastName').value.trim(); 
                const firstName = document.getElementById('userFirstName').value.trim(); 
                const userProfile = { 
                    id: 'main',
                    lastName: lastName, 
                    firstName: firstName, 
                    nameFormat: 'chinese', 
                    gender: document.getElementById('userGender').value, 
                    house: document.getElementById('userHouse').value, 
                    blood: document.getElementById('userBlood').value, 
                    age: document.getElementById('userAgeYear').value,
                    wand: { 
                        core: document.getElementById('wandCore').value, 
                        wood: document.getElementById('wandWood').value||'未知', 
                        length: document.getElementById('wandLength').value||'未知', 
                        flex: document.getElementById('wandFlex').value||'未知' 
                    }, 
                    patronus: document.getElementById('userPatronus').value||'未知', 
                    pet: document.getElementById('userPet').value||'无', 
                    appearance: document.getElementById('userAppearance').value||'普通', 
                    personality: document.getElementById('userPersonality').value||'友好', 
                    identity: document.getElementById('userIdentity').value||'未知', 
                    signature: document.getElementById('userSignature').value||'荣耀永恒！', 
                    avatar: null, 
                    fontUrl: null, 
                    fontFamily: null, 
                    customEmojis: {} 
                };
                
                userProfile.name = (userProfile.lastName + userProfile.firstName) || '新生';
                
                state.userProfile = userProfile;
                state.appInitialized = true;
                state.currentView = 'messages';
                
                await db.userProfile.put(userProfile);
                await initializeDefaultData(userProfile.house);
                await db.appState.put({ id: 'main', initialized: true, currentView: 'messages' });
                renderApp(true);
            }); 
        }
        
        function addLongPressListener(element, callback) {
            let pressTimer = null;
            let longPressTriggered = false;
            const onTouchStart = (e) => {
                longPressTriggered = false;
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                    callback(e);
                    longPressTriggered = true;
                }, 500);
            };
            const onTouchEnd = (e) => {
                if (pressTimer) clearTimeout(pressTimer);
                if (longPressTriggered) {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                }
            };
            
            const onTouchMove = () => {
                if (pressTimer) clearTimeout(pressTimer);
            };
            const onContextMenu = (e) => {
                e.preventDefault();
                callback(e);
            };
            element.addEventListener('touchstart', onTouchStart, { passive: false });
            element.addEventListener('touchend', onTouchEnd);
            element.addEventListener('touchcancel', onTouchMove);
            element.addEventListener('touchmove', onTouchMove);
            element.addEventListener('contextmenu', onContextMenu);
        }
        function bindMainEvents() { 
            queryDOMElements(); 
            applyHouseTheme(state.userProfile.house); 
            if (state.userProfile.fontUrl || state.userProfile.fontFamily) { 
                applyCustomFont(state.userProfile.fontUrl, state.userProfile.fontFamily); 
            } 
            navItems.forEach(item => item.addEventListener('click', function() { switchView(this.dataset.view); })); 
            document.getElementById('settingsBtn').addEventListener('click', () => switchView('profile')); 
            backButton.addEventListener('click', () => {
                const previous = state.previousView || 'messages';
                if (state.currentView === 'chat' && state.currentChat.isTriwizard) {
                    switchView('triwizard');
                } else {
                    switchView(previous);
                }
            }); 
            switchView(state.currentView || 'messages'); 
            window.addEventListener('click', () => contextMenu.classList.add('hidden'));
        }
        window.bindMessagesEvents = function() {
            document.getElementById('startTriwizardBtn')?.addEventListener('click', () => switchView('triwizard'));
            document.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('click', async function() {
                    const chatId = this.dataset.chatId;
                    const chat = await db.chats.get(chatId);
                    if (chat) {
                        state.currentChat = chat;
                        switchView('chat');
                    } else {
                        state.currentChat = state.chats.find(c => c.id === chatId);
                        if (state.currentChat) switchView('chat');
                    }
                });
                addLongPressListener(item, (e) => {
                    e.preventDefault();
                    const chat = state.chats.find(c => c.id === item.dataset.chatId);
                    const type = chat.isGroup ? 'groupChatItem' : 'chatItem';
                    showContextMenu(e, type, item.dataset.chatId);
                });
            });
        }
        window.bindContactsEvents = function() {
            const tabs = document.querySelectorAll('.tab');
            const contactsContent = document.getElementById('contactsContent');
            
            function updateContactsTabView(activeTab) {
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-tab="${activeTab}"]`).classList.add('active');
                if (activeTab === 'friends') {
                    renderGroupedContacts();
                } else {
                    renderGroupsList();
                }
            }
            
            tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    updateContactsTabView(e.currentTarget.dataset.tab);
                });
            });
            
            updateContactsTabView('friends');
        }
        function bindFriendsTabEvents() {
            document.getElementById('manageGroupsBtn')?.addEventListener('click', showManageGroupsDialog);
        }
        function bindFriendItemEvents() {
             document.querySelectorAll('.friend-item').forEach(item => { 
                item.addEventListener('click', async function() { 
                    state.activeContactId = this.dataset.contactId; 
                    await updateAppState();
                    const contact = await db.contacts.get(state.activeContactId);
                    showDialog(`<div class="dialog-title">${contact.name}</div><div class="dialog-actions" style="flex-direction: column; gap: 10px;"><button class="dialog-btn" id="dialogStartChat">进入对话</button><button class="dialog-btn" id="dialogEditFriend">好友介绍</button></div>`); 
                    
                    document.getElementById('dialogStartChat').onclick = async () => { 
                        hideDialog(); 
                        const currentContact = await db.contacts.get(state.activeContactId);
                        let chat = await db.chats.where('contactId').equals(state.activeContactId).first();
                        
                        if (!chat) { 
                            chat = { id: `chat_${Date.now()}`, contactId: currentContact.id, name: currentContact.name, isGroup: false, members: [], lastMessage: '可以开始聊天了', time: new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'}), messages: [], background: null, isPinned: false, summary: "", isHidden: false, isOfflineMode: false }; 
                            await db.chats.add(chat);
                            state.chats.unshift(chat);
                        } else { 
                            chat.isHidden = false; 
                            await db.chats.put(chat);
                            const existingChatIndex = state.chats.findIndex(m => m.id === chat.id);
                            if(existingChatIndex > -1) state.chats[existingChatIndex].isHidden = false;
                        } 
                        state.currentChat = chat; 
                        switchView('chat'); 
                    }; 
                    document.getElementById('dialogEditFriend').onclick = () => { 
                        hideDialog(); 
                        switchView('editFriend'); 
                    }; 
                });
                addLongPressListener(item, (e) => {
                    e.preventDefault();
                    showContextMenu(e, 'friendItem', item.dataset.contactId);
                });
            }); 
        }
        window.bindProfileEvents = function() {
            if (state.apiConfig.model) {
                const select = document.getElementById('apiModelSelect');
                if(select) {
                    select.innerHTML = `<option value="${state.apiConfig.model}">${state.apiConfig.model}</option>`;
                    select.value = state.apiConfig.model;
                }
            }
            document.getElementById('fetchModelsBtn').addEventListener('click', async (e) => {
                const btn = e.currentTarget;
                btn.innerText = "获取中...";
                btn.disabled = true;
                const tempConfig = { url: document.getElementById('apiUrl').value.trim(), key: document.getElementById('apiKey').value.trim() };
                try {
                    const models = await fetchApiModels(tempConfig);
                    const select = document.getElementById('apiModelSelect');
                    select.innerHTML = '';
                    if (models.length > 0) {
                        models.forEach(modelName => {
                            const option = document.createElement('option');
                            option.value = modelName;
                            option.textContent = modelName;
                            select.appendChild(option);
                        });
                        if (state.apiConfig.model && models.includes(state.apiConfig.model)) {
                            select.value = state.apiConfig.model;
                        }
                        alert(`成功获取 ${models.length} 个模型！`);
                    } else {
                        select.innerHTML = '<option value="">未能获取模型</option>';
                         alert('未能获取任何模型，请检查API设置。');
                    }
                } catch (error) {
                    alert(`获取模型失败: ${error.message}`);
                } finally {
                    btn.innerText = "获取模型";
                    btn.disabled = false;
                }
            });
            document.getElementById('testApiBtn').addEventListener('click', async (e) => {
                const btn = e.currentTarget;
                btn.innerText = "测试中...";
                btn.disabled = true;
                const testConfig = { url: document.getElementById('apiUrl').value.trim(), key: document.getElementById('apiKey').value.trim(), model: document.getElementById('apiModelSelect').value };
                try {
                    const result = await callApi("你好", [], testConfig);
                    if (result) {
                        alert("✅ 连接成功！");
                    } else {
                        alert("❌ 连接失败！API返回了空响应，但没有报错。请检查模型是否兼容。");
                    }
                } catch (error) {
                    let userFriendlyError = `❌ 连接失败！\n原因: ${error.message}\n\n`;
                    if (error instanceof TypeError && error.message.includes("fetch")) {
                         userFriendlyError += "提示: 这通常是网络问题或浏览器的CORS跨域安全策略导致的。如果您正在尝试连接官方API（如api.openai.com），这是预期的行为，因为它们不允许从浏览器直接调用。请改用支持CORS的中转API地址。";
                    } else {
                         userFriendlyError += "提示: 请仔细检查您的API URL、API Key和所选的模型名称是否正确无误。";
                    }
                    alert(userFriendlyError);
                } finally {
                    btn.innerText = "测试连接";
                    btn.disabled = false;
                }
            });
            
            document.querySelector('.profile-name').addEventListener('click', () => {
                const p = state.userProfile;
                const isChineseChecked = p.nameFormat === 'western' ? '' : 'checked'; 
                const isWesternChecked = p.nameFormat === 'western' ? 'checked' : '';
                const dialogHtml = `
                    <div class="dialog-title">修改姓名</div>
                    <div class="form-group">
                        <label for="dialogLastName">姓</label>
                        <input type="text" id="dialogLastName" value="${p.lastName || ''}" style="-webkit-user-select: text; user-select: text;">
                    </div>
                    <div class="form-group">
                        <label for="dialogFirstName">名</label>
                        <input type="text" id="dialogFirstName" value="${p.firstName || ''}" style="-webkit-user-select: text; user-select: text;">
                    </div>
                    <div class="form-group">
                        <label>显示格式</label>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <label style="display: flex; align-items: center;"><input type="radio" name="nameFormat" value="chinese" ${isChineseChecked} style="width: 20px; height: 20px; margin-right: 8px;"> 姓+名 (例如：布莱克奥利维娅)</label>
                            <label style="display: flex; align-items: center;"><input type="radio" name="nameFormat" value="western" ${isWesternChecked} style="width: 20px; height: 20px; margin-right: 8px;"> 名·姓 (例如：奥利维娅·布莱克)</label>
                        </div>
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn cancel-btn" id="dialog-name-cancel">取消</button>
                        <button class="dialog-btn" id="dialog-name-save">保存</button>
                    </div>
                `;
                showDialog(dialogHtml);
                
                document.getElementById('dialog-name-save').onclick = async () => {
                    const newLastName = document.getElementById('dialogLastName').value.trim();
                    const newFirstName = document.getElementById('dialogFirstName').value.trim();
                    const newFormat = document.querySelector('input[name="nameFormat"]:checked').value;
                    if (!newLastName && !newFirstName) {
                        alert("姓和名至少需要填写一个！");
                        return;
                    }
                    const profile = state.userProfile;
                    profile.lastName = newLastName;
                    profile.firstName = newFirstName;
                    profile.nameFormat = newFormat;
                    
                    if (newFormat === 'western' && newFirstName && newLastName) {
                        profile.name = `${newFirstName}·${newLastName}`;
                    } else {
                        profile.name = newLastName + newFirstName;
                    }
                    if (!profile.name) {
                        profile.name = "新生"; 
                    }
                    await db.userProfile.put(profile);
                    hideDialog();
                    switchView('profile', true);
                };
                
                document.getElementById('dialog-name-cancel').onclick = hideDialog;
            });
            document.querySelectorAll('.editable').forEach(el => {
                el.addEventListener('click', async e => {
                    const target = e.currentTarget;
                    const parentKey = target.dataset.parentKey;
                    const key = target.dataset.key;
                    if (!key) return;
                    const promptTitle = target.title || `修改 ${key}`;
                    const oldValue = target.textContent;
                    
                    const dialogHtml = `
                        <div class="dialog-title">${promptTitle}</div>
                        <div class="form-group">
                            <textarea id="dialog-edit-input" rows="4" style="-webkit-user-select: text; user-select: text;">${oldValue}</textarea>
                        </div>
                        <div class="dialog-actions">
                            <button class="dialog-btn cancel-btn" id="dialog-edit-cancel">取消</button>
                            <button class="dialog-btn" id="dialog-edit-save">保存</button>
                        </div>
                    `;
                    showDialog(dialogHtml);
                    
                    document.getElementById('dialog-edit-save').onclick = async () => {
                        const newValue = document.getElementById('dialog-edit-input').value;
                        if (newValue.trim() !== oldValue) {
                            if (parentKey && state.userProfile[parentKey]) {
                                state.userProfile[parentKey][key] = newValue.trim();
                            } else {
                                state.userProfile[key] = newValue.trim();
                            }
                            await db.userProfile.put(state.userProfile);
                            hideDialog();
                            switchView('profile', true);
                        } else {
                            hideDialog();
                        }
                    };
                    document.getElementById('dialog-edit-cancel').onclick = hideDialog;
                });
            });
            
            document.getElementById('logoutBtn').addEventListener('click', async () => { if (confirm('将清除所有数据并重启，确定吗？')) { await db.delete(); window.location.reload(); } });
            
            document.getElementById('saveApiConfig').addEventListener('click', async () => {
                try {
                    const newConfig = {
                        id: 'main',
                        provider: document.getElementById('apiProvider').value,
                        url: document.getElementById('apiUrl').value.trim(),
                        key: document.getElementById('apiKey').value.trim(),
                        model: document.getElementById('apiModelSelect').value
                    };
                    state.apiConfig = newConfig;
                    await db.apiConfig.put(newConfig);
                    alert('API设置已保存！');
                } catch (error) {
                    console.error("Failed to save API config:", error);
                    alert("错误：API设置保存失败！请检查浏览器控制台获取更多信息。");
                }
            });
            document.getElementById('profileAvatarUpload').addEventListener('change', e => handleAvatarUpload(e, async dataUrl => { 
                state.userProfile.avatar = dataUrl; 
                await db.userProfile.put(state.userProfile);
                switchView('profile', true); 
            })); 
            document.getElementById('applyFontBtn').addEventListener('click', async () => { 
                const fontUrl = document.getElementById('fontUrlInput').value.trim(); 
                const fontFamily = document.getElementById('fontFamilyInput').value.trim(); 
                await applyCustomFont(fontUrl, fontFamily); 
                alert('字体已应用！'); 
            });
            
            document.getElementById('exportDataBtn').addEventListener('click', async () => {
                try {
                    const allData = {};
                    for (const table of db.tables) {
                        allData[table.name] = await table.toArray();
                    }
                    const dataStr = JSON.stringify(allData, null, 2);
                    const filename = `hogwarts_qq_save_${new Date().toISOString().slice(0,10)}.json`;
                    const blob = new Blob([dataStr], {type: "application/json"});
                    const fileToShare = new File([blob], filename, { type: 'application/json' });
                    
                    if (navigator.canShare && navigator.canShare({ files: [fileToShare] })) {
                        try {
                            await navigator.share({
                                files: [fileToShare],
                                title: '霍格沃茨QQ数据备份',
                                text: `备份文件: ${filename}`
                            });
                            return;
                        } catch (err) {
                            console.error("Web Share API 失败:", err);
                        }
                    }
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                    
                    if (isIOS) {
                        showDialog(`
                            <div class="dialog-title">iOS 导出 (备用方案)</div>
                            <p style="text-align: left; line-height: 1.6; margin-bottom: 20px;">
                                您的浏览器不支持直接保存文件，请使用以下手动步骤：<br><br>
                                <strong>1. 点击“一键复制”按钮。</strong><br>
                                <strong>2. 打开手机的“备忘录”App。</strong><br>
                                <strong>3. 新建一个备忘录，长按并“粘贴”。</strong><br>
                                <strong>4. 点击备忘录右上角的分享按钮，选择“存储到‘文件’”。</strong><br>
                                <strong>5. 将文件名修改为 <code style="background: #555; padding: 2px 5px; border-radius: 4px;">${filename}</code> 并保存。</strong>
                            </p>
                            <div class="form-group">
                                <textarea id="ios-export-textarea" rows="5" readonly style="background: #111; -webkit-user-select: text; user-select: text;">${dataStr}</textarea>
                            </div>
                            <div class="dialog-actions" style="justify-content: center;">
                                <button id="ios-copy-btn" class="dialog-btn">一键复制</button>
                            </div>
                        `);
                        document.getElementById('ios-copy-btn').onclick = () => {
                            const textarea = document.getElementById('ios-export-textarea');
                            textarea.select();
                            textarea.setSelectionRange(0, 99999);
                            try {
                                document.execCommand('copy');
                                alert('已复制到剪贴板！现在可以去备忘录粘贴了。');
                            } catch (err) {
                                alert('自动复制失败，请手动长按文本框进行复制。');
                            }
                        };
                    } else {
                        const a = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }
                } catch (e) {
                    console.error("导出数据失败:", e);
                    alert("导出数据失败！");
                }
            });
            const importDataInput = document.getElementById('importDataInput');
            document.getElementById('importDataBtn').addEventListener('click', () => {
                importDataInput.click();
            });
            importDataInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                if (confirm('警告：导入数据将覆盖当前所有进度和设置。确定要继续吗？')) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            let importedData = JSON.parse(e.target.result);
                            
                            if (importedData.appInitialized && importedData.userProfile && !Array.isArray(importedData.userProfile)) {
                                console.log("检测到旧版localStorage数据格式，正在转换...");
                                const oldState = importedData;
                                const migratedData = {
                                    appState: [{ id: 'main', initialized: oldState.appInitialized, currentView: oldState.currentView, activeContactId: oldState.activeContactId, previousView: oldState.previousView, replyingTo: oldState.replyingTo }],
                                    userProfile: [{ id: 'main', ...oldState.userProfile }],
                                    apiConfig: [{ id: 'main', ...oldState.apiConfig }],
                                    contacts: oldState.contacts || [],
                                    chats: oldState.messages || [], 
                                    myMoments: oldState.myMoments || [],
                                    friendMoments: oldState.friendMoments || [],
                                    groups: [],
                                    triwizardChapters: oldState.triwizardChapters || []
                                };
                                importedData = migratedData;
                                console.log("数据转换完成。");
                            }
                            if ((!importedData.triwizardChapters || importedData.triwizardChapters.length === 0) && importedData.userProfile && importedData.userProfile[0]) {
                                console.log("三强争霸赛数据缺失，正在为导入的数据生成默认章节...");
                                const playerHouse = importedData.userProfile[0].house || 'slytherin';
                                importedData.triwizardChapters = generateDefaultTriwizardChapters(playerHouse);
                            }
                             
                            const allDefaultContacts = Object.values(getDefaultContacts()).flat();
                            if (importedData.contacts && Array.isArray(importedData.contacts)) {
                                const importedContactIds = new Set(importedData.contacts.map(c => c.id));
                                const missingContacts = allDefaultContacts.filter(c => !c.id.startsWith('oc') && !importedContactIds.has(c.id));
                                if (missingContacts.length > 0) {
                                    importedData.contacts.push(...missingContacts);
                                }
                            } else {
                                importedData.contacts = allDefaultContacts;
                            }
                            if ((!importedData.groups || importedData.groups.length === 0) && importedData.userProfile[0]) {
                                const playerHouse = importedData.userProfile[0].house;
                                const d = getDefaultContacts();
                                const allHouses = ['slytherin', 'gryffindor', 'ravenclaw', 'hufflepuff'];
                                const otherHouses = allHouses.filter(h => h !== playerHouse);
                                importedData.groups = [
                                    { id: 'group_professors', name: '教授', contactIds: d.professors.map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false },
                                    { id: `group_${playerHouse}`, name: HOUSE_INFO[playerHouse].name, contactIds: d[playerHouse].map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false },
                                    { id: 'group_other_houses', name: '其他学院', contactIds: otherHouses.flatMap(h => d[h].map(c => c.id)), isDeletable: true, isRenamable: true, isPinned: false },
                                    { id: 'group_oc', name: '原创角色', contactIds: (importedData.contacts || []).filter(c => c.oc).map(c => c.id), isDeletable: true, isRenamable: true, isPinned: false }
                                ];
                            } else if (importedData.groups) {
                                importedData.groups.forEach(g => {
                                    if(g.isPinned === undefined) g.isPinned = false;
                                });
                            }
                            const tablesToMigrateKey = ['appState', 'userProfile', 'apiConfig'];
                            for (const tableName of tablesToMigrateKey) {
                                if (importedData[tableName] && Array.isArray(importedData[tableName])) {
                                    importedData[tableName].forEach(item => {
                                        if (item.key && item.id === undefined) {
                                            item.id = item.key;
                                            delete item.key;
                                        }
                                    });
                                }
                            }
                            
                            if (importedData.userProfile && importedData.userProfile[0]) {
                                const p = importedData.userProfile[0];
                                if (!p.customEmojis) p.customEmojis = {};
                                if (p.nameFormat === undefined) p.nameFormat = 'chinese'; 
                                if (p.lastName === undefined) p.lastName = '';
                                if (p.firstName === undefined) p.firstName = '';
                            }
                            if (importedData.chats && Array.isArray(importedData.chats)) {
                                importedData.chats.forEach(chat => {
                                    if (chat.isPinned === undefined) chat.isPinned = false;
                                    if (chat.isHidden === undefined) chat.isHidden = false;
                                    if (chat.summary === undefined) chat.summary = "";
                                    if (chat.isOfflineMode === undefined) chat.isOfflineMode = false;
                                    if (chat.isGroup === undefined) chat.isGroup = false; 
                                    if (chat.members === undefined) chat.members = []; 
                                    if (chat.isGroup) {
                                        if (chat.avatar === undefined) chat.avatar = null;
                                        if (chat.myNickname === undefined) chat.myNickname = null;
                                        if (Array.isArray(chat.members)) {
                                            chat.members.forEach(m => {
                                                if (m.nickname === undefined) m.nickname = null;
                                                if (m.persona === undefined) m.persona = null;
                                                if (m.sharedHistory === undefined) m.sharedHistory = null;
                                            });
                                        }
                                    }
                                });
                            }
                            if (importedData.contacts && Array.isArray(importedData.contacts)) {
                                importedData.contacts.forEach(c => {
                                    if (c.isPinned === undefined) c.isPinned = false;
                                });
                            }
                            await db.transaction('rw', db.tables, async () => {
                                for (const tableName in importedData) {
                                    if (db[tableName]) {
                                        await db[tableName].clear();
                                        if (importedData[tableName].length > 0) {
                                            await db[tableName].bulkPut(importedData[tableName]);
                                        }
                                    }
                                }
                            });
                            alert('数据导入成功！应用将重新加载。');
                            window.location.reload();
                        } catch (error) {
                            alert(`导入失败：无法解析文件。\n错误: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                }
                event.target.value = '';
            });
        }
        window.bindChatEvents = function() {
            // ✨ 新增的搜索按钮事件绑定
            document.getElementById('searchChatBtn')?.addEventListener('click', () => {
                showSearchDialog();
            });
            const chatHistoryEl = document.getElementById('chatHistory');
            const emojiPanel = document.getElementById('emojiPanel');
            if (chatHistoryEl) {
                chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
            }
            
            document.getElementById('memoryBtn')?.addEventListener('click', () => {
                showDialog(`
                    <div class="dialog-title">编辑记忆概要</div>
                    <div class="form-group">
                        <label>手动总结你们的故事进展：</label>
                        <textarea id="memorySummary" rows="8" style="font-size: 14px;">${state.currentChat.summary || ''}</textarea>
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn cancel-btn">取消</button>
                        <button id="saveMemoryBtn" class="dialog-btn">保存</button>
                    </div>
                `);
                document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
                document.getElementById('saveMemoryBtn').onclick = async () => {
                    state.currentChat.summary = document.getElementById('memorySummary').value;
                    await db.chats.put(state.currentChat);
                    hideDialog();
                    alert("记忆已更新！");
                };
            });
            const applyChatBackground = () => { if (!chatHistoryEl) return; if (state.currentChat.background) { chatHistoryEl.style.backgroundImage = `url(${state.currentChat.background})`; chatHistoryEl.style.backgroundSize = 'cover'; chatHistoryEl.style.backgroundPosition = 'center'; chatHistoryEl.classList.add('has-custom-bg'); } else { chatHistoryEl.style.backgroundImage = 'none'; chatHistoryEl.classList.remove('has-custom-bg'); } };
            if (!state.currentChat.isTriwizard) applyChatBackground();
            const sendText = async () => { const text = document.getElementById('messageInput').value.trim(); if (text === '') return; await addMessageToChat({ type: 'text', text, quote: state.replyingTo }); document.getElementById('messageInput').value = ''; state.replyingTo = null; await updateAppState(); };
            
            const offlineModeBtn = document.getElementById('offlineModeBtn');
            if (offlineModeBtn) {
                if (state.currentChat.isOfflineMode) {
                    offlineModeBtn.classList.add('active');
                }
                offlineModeBtn.addEventListener('click', async () => {
                    state.currentChat.isOfflineMode = !state.currentChat.isOfflineMode;
                    offlineModeBtn.classList.toggle('active');
                    await db.chats.put(state.currentChat);
                    alert(state.currentChat.isOfflineMode ? '线下模式已开启' : '线下模式已关闭');
                });
            }
            document.getElementById('messageInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendText(); } });
            document.getElementById('sendMessageBtn').addEventListener('click', sendText);
            document.getElementById('aiInitiateMessageBtn').addEventListener('click', () => getApiResponse("ai_initiate"));
            document.getElementById('saveStoryBtn')?.addEventListener('click', () => showSaveStoryDialog(state.currentChat.id));
            document.getElementById('sendImageBtn')?.addEventListener('click', () => { showDialog(`<div class="dialog-title">发送图片</div><div class="form-group"><label>图片描述</label><textarea id="imageDesc" rows="3"></textarea></div><div class="form-group"><label>上传图片</label><input type="file" id="imageUpload" accept="image/*"><img id="imagePreview" class="image-preview hidden"></div><div class="dialog-actions"><button class="dialog-btn cancel-btn">取消</button><button id="confirmSendImage" class="dialog-btn">发送</button></div>`); document.getElementById('imageUpload').onchange = e => handleAvatarUpload(e, dataUrl => { document.getElementById('imagePreview').src = dataUrl; document.getElementById('imagePreview').classList.remove('hidden'); }); document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog; document.getElementById('confirmSendImage').onclick = async () => { const text = document.getElementById('imageDesc').value; const imageData = document.getElementById('imagePreview').src; if(imageData) { await addMessageToChat({type:'image', text, imageData}); hideDialog(); } else { alert("请上传图片"); } }; });
            
            document.getElementById('sendGiftBtn')?.addEventListener('click', () => {
                const isGroup = state.currentChat.isGroup;
                let recipientHtml = '';
                if(isGroup) {
                    recipientHtml = `<div class="form-group"><label>赠送对象</label><select id="giftRecipient">`;
                    state.currentChat.members.forEach(member => {
                        recipientHtml += `<option value="${member.name}">${member.nickname || member.name}</option>`;
                    });
                    recipientHtml += `</select></div>`;
                }
                showDialog(`<div class="dialog-title">赠送礼物</div>
                            ${recipientHtml}
                            <div class="form-group"><label>礼物外观 (可选)</label><input type="file" id="giftImageUpload" accept="image/*"><img id="giftImagePreview" class="image-preview hidden"></div>
                            <div class="form-group"><label>礼物简介</label><input type="text" id="giftName"></div>
                            <div class="form-group"><label>礼物价格</label><input type="text" id="giftPrice"></div>
                            <div class="form-group"><label>赠送心意</label><textarea id="giftMessage" rows="2"></textarea></div>
                            <div class="dialog-actions"><button class="dialog-btn cancel-btn">取消</button><button id="confirmSendGift" class="dialog-btn">赠送</button></div>`);
                
                document.getElementById('giftImageUpload').onchange = e => handleAvatarUpload(e, dataUrl => { document.getElementById('giftImagePreview').src = dataUrl; document.getElementById('giftImagePreview').classList.remove('hidden'); });
                document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
                document.getElementById('confirmSendGift').onclick = async () => {
                    const gift = { 
                        image: document.getElementById('giftImagePreview').src || null, 
                        name: document.getElementById('giftName').value, 
                        price: document.getElementById('giftPrice').value, 
                        message: document.getElementById('giftMessage').value,
                        recipient: isGroup ? document.getElementById('giftRecipient').value : null
                    };
                    if(gift.name) { 
                        await addMessageToChat({type: 'gift', gift});
                        hideDialog();
                    } else { 
                        alert("请填写礼物简介");
                    }
                };
            });
            document.getElementById('chatSettingsBtn')?.addEventListener('click', () => { showDialog(`<div class="dialog-title">聊天设置</div><div class="dialog-actions" style="flex-direction: column; gap: 10px;"><button class="dialog-btn" id="setBgBtn">设置背景</button><input type="file" id="bgUpload" class="hidden" accept="image/*"><button class="dialog-btn" id="resetBgBtn">恢复默认</button></div>`); document.getElementById('setBgBtn').onclick = () => document.getElementById('bgUpload').click(); document.getElementById('resetBgBtn').onclick = async () => { state.currentChat.background = null; applyChatBackground(); await db.chats.put(state.currentChat); hideDialog(); }; document.getElementById('bgUpload').onchange = e => handleAvatarUpload(e, async dataUrl => { state.currentChat.background = dataUrl; applyChatBackground(); await db.chats.put(state.currentChat); hideDialog(); }); });
            
            const groupSettingsBtn = document.getElementById('groupSettingsBtn');
            if (groupSettingsBtn) {
                groupSettingsBtn.addEventListener('click', () => showGroupSettingsDialog());
            }
            const addEmojiBtn = document.getElementById('addEmojiBtn');
            if (addEmojiBtn) {
                addEmojiBtn.addEventListener('click', () => {
                    showAddEmojiModal();
                });
            }
            const deleteEmojiBtn = document.getElementById('deleteEmojiBtn');
            if (deleteEmojiBtn) {
                deleteEmojiBtn.addEventListener('click', () => {
                    showDeleteEmojiModal();
                });
            }
            const emojiBtn = document.getElementById('emojiBtn');
            if(emojiBtn) {
                emojiBtn.addEventListener('click', (e) => { e.stopPropagation(); renderEmojiPanel(); emojiPanel.style.display = emojiPanel.style.display === 'block' ? 'none' : 'block'; });
                document.addEventListener('click', (e) => { if (emojiPanel && !emojiPanel.contains(e.target) && e.target.id !== 'emojiBtn' && !e.target.closest('#emojiBtn')) { emojiPanel.style.display = 'none'; } });
            }
            document.querySelectorAll('.message').forEach(el => {
                addLongPressListener(el, (e) => {
                    showContextMenu(e, 'message', el.dataset.messageId);
                });
            });
        }
        // ✨ --- 新增的搜索功能代码 START ---
        /**
         * 显示搜索输入对话框
         */
        function showSearchDialog() {
            const dialogHtml = `
                <div class="dialog-title">搜索聊天记录</div>
                <div class="form-group">
                    <label for="searchInput">关键词</label>
                    <input type="text" id="searchInput" placeholder="输入要搜索的内容..." style="-webkit-user-select: text; user-select: text;">
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn cancel-btn">取消</button>
                    <button class="dialog-btn" id="executeSearchBtn">搜索</button>
                </div>
            `;
            showDialog(dialogHtml);
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('executeSearchBtn').onclick = executeSearch;
            // 为输入框添加回车键监听，方便操作
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    executeSearch();
                }
            });
            document.getElementById('searchInput').focus();
        }
        /**
         * 执行搜索并显示结果
         */
        function executeSearch() {
            const keyword = document.getElementById('searchInput').value.trim();
            if (!keyword) {
                alert('请输入关键词！');
                return;
            }
            // 筛选仅包含文本类型的消息，并进行不区分大小写的搜索
            const results = state.currentChat.messages.filter(msg => 
                (msg.type === 'text' || !msg.type) && msg.text && msg.text.toLowerCase().includes(keyword.toLowerCase())
            );
            if (results.length === 0) {
                alert('未找到包含该关键词的记录。');
            } else {
                showSearchResults(results, keyword);
            }
        }
        /**
         * 在对话框中显示搜索结果
         * @param {Array} results - 搜索到的消息对象数组
         * @param {string} keyword - 用于高亮的关键词
         */
        function showSearchResults(results, keyword) {
            // 按时间倒序显示，最近的记录在最上面
            results.reverse();
            let resultsHtml = `
                <div class="dialog-title">搜索结果 (${results.length}条)</div>
                <div class="search-results-container">`;
            
            const keywordRegex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
            results.forEach(msg => {
                // 高亮关键词
                const highlightedText = msg.text.replace(keywordRegex, match => `<strong class="highlight">${match}</strong>`);
                resultsHtml += `
                    <div class="search-result-item" data-message-id="${msg.id}">
                        <div class="search-result-header">
                            <strong>${msg.sender || '未知发送者'}</strong>
                            <span class="time">${msg.time}</span>
                        </div>
                        <div class="search-result-content">${highlightedText}</div>
                    </div>
                `;
            });
            resultsHtml += `</div>`;
            // 直接更新当前对话框的内容
            const dialogContent = document.getElementById('dialogContent');
            dialogContent.innerHTML = `<button class="close-dialog-btn">&times;</button>${resultsHtml}`;
            wizardDialog.querySelector('.close-dialog-btn').onclick = hideDialog;
            // 为每一条结果绑定点击跳转事件
            document.querySelectorAll('.search-result-item').forEach(item => {
                item.onclick = () => {
                    const messageId = item.dataset.messageId;
                    hideDialog(); // 关闭搜索结果框
                    // 在聊天记录中找到对应的消息元素
                    const targetMessage = document.querySelector(`.message[data-message-id="${messageId}"]`);
                    if (targetMessage) {
                        // 滚动到该消息的位置
                        targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // 添加一个临时的闪烁或高亮效果，以示提醒
                        targetMessage.style.transition = 'background-color 0.5s ease-in-out';
                        targetMessage.style.backgroundColor = 'var(--theme-accent)';
                        setTimeout(() => {
                            targetMessage.style.backgroundColor = '';
                        }, 2000);
                    }
                };
            });
        }
        // ✨ --- 新增的搜索功能代码 END ---
        window.bindMomentsEvents = function() {
            const renderMomentsList = (moments) => {
                if (!moments || moments.length === 0) return `<div class="card">这里空空如也...</div>`;
                
                const sortedMoments = [...moments].sort((a, b) => {
                    const timeA = parseInt(a.id.split('_')[1]);
                    const timeB = parseInt(b.id.split('_')[1]);
                    return timeB - timeA;
                });
                return sortedMoments.map((moment, momentIndex) => {
                    const contact = state.contacts.find(c => c.name === moment.name) || { house: moment.house, avatar: null, icon: '🏰' };
                    const house = contact.house || 'hogwarts';
                    const colors = HOUSE_INFO[house].colors;
                    const playerHasLiked = (moment.likedBy || []).includes(state.userProfile.name);
                    const commentsHtml = (moment.comments || []).map((comment, commentIndex) => `
                        <div class="comment" data-moment-id="${moment.id}" data-comment-index="${commentIndex}">
                            <strong>${comment.author}</strong>
                            ${comment.replyTo ? `<span class="reply-to"> @ ${comment.replyTo}</span>` : ''}: 
                            ${comment.text}
                        </div>
                    `).join('');
                    return `<div class="moment-item" data-moment-id="${moment.id}">
                                <div class="moment-header">
                                    <div class="moment-avatar avatar" style="${getAvatarStyle(contact.avatar, colors.dark)}">${!contact.avatar ? contact.icon : ''}</div>
                                    <div class="moment-user"><div>${moment.name}</div><div class="moment-time">${moment.time}</div></div>
                                </div>
                                <div class="moment-content">${moment.content}</div>
                                ${moment.image ? `<img src="${moment.image}" class="moment-image">` : ''}
                                <div class="moment-footer">
                                    <div class="moment-footer-action like-btn ${playerHasLiked ? 'liked' : ''}"><i class="fas fa-heart"></i> ${(moment.likedBy || []).length}</div>
                                    <div class="moment-footer-action reply-btn"><i class="fas fa-comment"></i> 回复</div>
                                    <div class="moment-footer-action ai-reply-btn"><i class="fas fa-users"></i> 查看好友回复</div>
                                </div>
                                <div class="moment-comments">${commentsHtml}</div>
                                <div class="moment-comment-input-wrapper">
                                    <input type="text" placeholder="添加评论...">
                                    <button data-moment-id="${moment.id}">发送</button>
                                </div>
                            </div>`;
                }).join('');
            };
            const momentsContent = document.getElementById('momentsContent');
            const updateTabView = (activeTab) => {
                document.querySelector('.tab.active')?.classList.remove('active'); document.querySelector(`.tab[data-tab="${activeTab}"]`)?.classList.add('active');
                if (activeTab === 'friends') { momentsContent.innerHTML = `<button class="btn primary" id="generateMomentsBtn" style="width:100%; margin-bottom: 15px;">刷新好友动态</button><div id="friendMomentsList">${renderMomentsList(state.friendMoments)}</div>`; document.getElementById('generateMomentsBtn').onclick = () => generateAIFriendMoments(); } 
                else { momentsContent.innerHTML = `<button class="btn primary" id="newMomentBtn" style="width:100%; margin-bottom: 15px;">发布新动态</button><div id="myMomentsList">${renderMomentsList(state.myMoments)}</div>`; document.getElementById('newMomentBtn').onclick = () => switchView('newMoment'); }
                
                momentsContent.querySelectorAll('.like-btn').forEach(btn => btn.onclick = async (e) => {
                    const id = e.currentTarget.closest('.moment-item').dataset.momentId;
                    const isMyMoment = state.myMoments.some(m => m.id === id);
                    const moment = isMyMoment ? state.myMoments.find(m => m.id === id) : state.friendMoments.find(m => m.id === id);
                    if (moment) {
                        if (!moment.likedBy) moment.likedBy = [];
                        const userIndex = moment.likedBy.indexOf(state.userProfile.name);
                        if (userIndex > -1) {
                            moment.likedBy.splice(userIndex, 1);
                        } else {
                            moment.likedBy.push(state.userProfile.name);
                        }
                        if (isMyMoment) await db.myMoments.put(moment);
                        else await db.friendMoments.put(moment);
                        await getApiCommentForMoment(moment);
                        switchView('moments', true);
                    }
                });
                
                momentsContent.querySelectorAll('.reply-btn, .comment').forEach(el => el.onclick = (e) => {
                    const momentItem = e.currentTarget.closest('.moment-item');
                    const inputWrapper = momentItem.querySelector('.moment-comment-input-wrapper');
                    const inputField = inputWrapper.querySelector('input');
                    inputWrapper.classList.toggle('active');
                    if (inputWrapper.classList.contains('active')) {
                        inputField.focus();
                        if (e.currentTarget.classList.contains('comment')) {
                            const author = e.currentTarget.querySelector('strong').textContent;
                            if (author !== state.userProfile.name) {
                                inputField.value = `@${author} `;
                                inputField.dataset.replyTo = author;
                            }
                        } else {
                            inputField.value = '';
                            delete inputField.dataset.replyTo;
                        }
                    }
                });
                momentsContent.querySelectorAll('.ai-reply-btn').forEach(btn => btn.onclick = (e) => {
                    const id = e.currentTarget.closest('.moment-item').dataset.momentId;
                    const m = (state.friendMoments || []).concat(state.myMoments || []).find(m=>m.id==id);
                    if(m) getApiCommentForMoment(m);
                });
                momentsContent.querySelectorAll('.moment-comment-input-wrapper button').forEach(btn => btn.onclick = async (e) => {
                    const id = e.currentTarget.dataset.momentId;
                    const isMyMoment = state.myMoments.some(m => m.id === id);
                    const moment = isMyMoment ? state.myMoments.find(m => m.id === id) : state.friendMoments.find(m => m.id === id);
                    if (moment) {
                        const inputField = e.currentTarget.previousElementSibling;
                        const content = inputField.value.trim();
                        if (content) {
                            if (!moment.comments) moment.comments = [];
                            const replyTo = inputField.dataset.replyTo;
                            let text = content;
                            if (replyTo && content.startsWith(`@${replyTo} `)) {
                                text = content.substring(`@${replyTo} `.length);
                            }
                            moment.comments.push({ author: state.userProfile.name, text: text, replyTo: replyTo || null });
                            
                            await getApiCommentForMoment(moment);
                            
                            if (isMyMoment) await db.myMoments.put(moment);
                            else await db.friendMoments.put(moment);
                            
                            switchView('moments', true);
                        }
                    }
                });
                
                momentsContent.querySelectorAll('.moment-item').forEach(el => {
                    addLongPressListener(el, (e) => {
                        if (e.target.closest('.comment')) {
                            return;
                        }
                        e.stopPropagation();
                        const id = el.dataset.momentId;
                        showContextMenu(e, 'moment', id);
                    });
                });
                momentsContent.querySelectorAll('.comment').forEach(el => {
                    addLongPressListener(el, (e) => {
                        e.stopPropagation();
                        const id = el.dataset.momentId;
                        const commentIndex = el.dataset.commentIndex;
                        showContextMenu(e, 'comment', id, commentIndex);
                    });
                });
            };
            
            if (!state.activeMomentsTab) {
                state.activeMomentsTab = 'friends';
            }
            document.querySelectorAll('.tab').forEach(tab => tab.addEventListener('click', (e) => {
                state.activeMomentsTab = e.currentTarget.dataset.tab;
                updateTabView(state.activeMomentsTab);
            }));
            updateTabView(state.activeMomentsTab);
        }
        function showMomentVisibilityDialog(currentBlockedIds = []) {
            let contactsHtml = '<div style="max-height: 40vh; overflow-y: auto; text-align: left;">';
            state.contacts.forEach(contact => {
                const isChecked = currentBlockedIds.includes(contact.id);
                contactsHtml += `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="block_${contact.id}" value="${contact.id}" name="contact-to-block" ${isChecked ? 'checked' : ''} style="margin-right: 10px; width: 18px; height: 18px;">
                        <label for="block_${contact.id}" style="display: flex; align-items: center; gap: 8px;">
                            <div class="chat-avatar avatar" style="${getAvatarStyle(contact.avatar, '#ccc')}; width:30px; height:30px; font-size: 16px; flex-shrink: 0;">${!contact.avatar ? contact.icon : ''}</div>
                            <span>${contact.name}</span>
                        </label>
                    </div>`;
            });
            contactsHtml += '</div>';
            showDialog(`
                <div class="dialog-title">选择不可见的角色</div>
                ${contactsHtml}
                <div class="dialog-actions">
                    <button class="dialog-btn" id="confirmVisibility">确认</button>
                </div>
            `);
            document.getElementById('confirmVisibility').onclick = () => {
                const selected = document.querySelectorAll('input[name="contact-to-block"]:checked');
                const blockedIds = Array.from(selected).map(cb => cb.value);
                
                const publishBtn = document.getElementById('publishMoment');
                publishBtn.dataset.blockedIds = JSON.stringify(blockedIds);
                const visibilityBtn = document.getElementById('momentVisibilityBtn');
                if (blockedIds.length === 0) {
                    visibilityBtn.textContent = '公开';
                } else {
                    visibilityBtn.textContent = `对 ${blockedIds.length} 人不可见`;
                }
                
                hideDialog();
            };
        }
        window.bindNewMomentEvents = function() { 
            const publishBtn = document.getElementById('publishMoment');
            publishBtn.dataset.blockedIds = '[]'; 
            document.getElementById('momentVisibilityBtn').addEventListener('click', () => {
                const currentBlockedIds = JSON.parse(publishBtn.dataset.blockedIds || '[]' );
                showMomentVisibilityDialog(currentBlockedIds);
            });
            document.getElementById('cancelMoment').addEventListener('click', () => switchView('moments')); 
            
            publishBtn.addEventListener('click', async () => { 
                const content = document.getElementById('momentContent').value.trim(); 
                if (!content) return; 
                const blockedContactIds = JSON.parse(publishBtn.dataset.blockedIds || '[]');
                const newMoment = { 
                    id: `moment_${Date.now()}`, 
                    name: state.userProfile.name, 
                    house: state.userProfile.house, 
                    time: "刚刚", 
                    content, 
                    image: document.getElementById('momentImagePreview').src || null, 
                    comments: [], 
                    likedBy: [],
                    blockedContactIds: blockedContactIds
                }; 
                state.myMoments.unshift(newMoment);
                await db.myMoments.put(newMoment);
                await getApiCommentForMoment(newMoment);
                switchView('moments'); 
            }); 
            document.getElementById('momentImageUpload').onchange = e => handleAvatarUpload(e, dataUrl => { document.getElementById('momentImagePreview').src = dataUrl; document.getElementById('momentImagePreview').classList.remove('hidden'); }); 
        }
        window.bindEditFriendEvents = function() { 
            const c = state.contacts.find(c => c.id === state.activeContactId); 
            viewTitle.textContent = `编辑 - ${c.name}`; 
            const tabContent = document.getElementById('tabContent'); 
            document.querySelectorAll('.tab').forEach(tab => { 
                tab.addEventListener('click', function() { 
                    document.querySelector('.tab.active').classList.remove('active'); 
                    this.classList.add('active'); 
                    tabContent.innerHTML = this.dataset.tab === 'info' ? `${c.oc ? `<div class="form-group"><label>角色ID</label><input type="text" id="friendId" value="${c.id}"></div>` : ''}<div class="form-group"><label>基本信息</label><textarea id="friendInfo" rows="6">${c.info}</textarea></div>` : `<div class="form-group"><label>共同经历</label><textarea id="friendHistory" rows="6">${c.sharedHistory}</textarea></div>`; 
                }); 
            }); 
            document.getElementById('friendAvatarUpload').addEventListener('change', e => handleAvatarUpload(e, async dataUrl => { 
                c.avatar = dataUrl; 
                await db.contacts.put(c);
                switchView('editFriend', true); 
            })); 
            document.getElementById('saveFriendInfoBtn').addEventListener('click', async () => { 
                const info = document.getElementById('friendInfo')?.value; 
                const history = document.getElementById('friendHistory')?.value; 
                if(info !== undefined) c.info = info; 
                if(history !== undefined) c.sharedHistory = history; 
                if(c.oc) { 
                    const newId = document.getElementById('friendId')?.value.trim(); 
                    if (newId && newId !== c.id) { 
                        const exists = await db.contacts.get(newId);
                        if(exists) { 
                            alert('错误：该ID已被其他联系人使用，请输入一个唯一的ID。'); return; 
                        } 
                        await updateContactIdReferences(c.id, newId); 
                        await db.contacts.delete(c.id);
                        c.id = newId; c.name = newId; 
                    } 
                } 
                await db.contacts.put(c);
                alert('信息已保存！'); 
            }); 
        }    
        window.bindTriwizardEvents = function() {
            document.querySelectorAll('.twt-button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const chapterId = e.currentTarget.dataset.chapterId;
                    showChapterDialog(chapterId);
                });
            });
        }
        async function showChapterDialog(chapterId) {
            const chapter = await db.triwizardChapters.get(chapterId);
            if (!chapter) {
                console.error(`无法加载章节ID: ${chapterId}。数据可能已损坏或未初始化。`);
                alert("错误：无法加载章节数据！");
                return;
            }
            showDialog(`
                <div class="dialog-title">${chapter.name}</div>
                <div class="dialog-actions" style="flex-direction: column; gap: 10px; align-items: stretch;">
                    <button class="dialog-btn" id="restartStoryBtn">重开剧情</button>
                    <button class="dialog-btn" id="loadStoryBtn">读取记录</button>
                </div>
            `);
            document.getElementById('restartStoryBtn').onclick = () => startChapter(chapterId, false);
            document.getElementById('loadStoryBtn').onclick = () => startChapter(chapterId, true);
        }
        async function startChapter(chapterId, loadFromSave) {
            hideDialog();
            const chapter = await db.triwizardChapters.get(chapterId);
            let messages;
            if (loadFromSave) {
                const mainSaveSlot = chapter.savedSlots[chapter.mainSaveSlotIndex];
                if (mainSaveSlot && mainSaveSlot.messages) {
                    messages = mainSaveSlot.messages;
                } else {
                    alert("没有可读取的主要记录。将为您开启新剧情。");
                    messages = [{ id: `msg_${Date.now()}`, type: 'text', text: chapter.intro, time: '', incoming: true, sender: '旁白' }];
                }
            } else {
                messages = [{ id: `msg_${Date.now()}`, type: 'text', text: chapter.intro, time: '', incoming: true, sender: '旁白' }];
            }
            state.currentChat = {
                id: chapter.id,
                name: chapter.name,
                isTriwizard: true,
                messages: messages
            };
            switchView('chat');
        }
        async function showSaveStoryDialog(chapterId) {
            const chapter = await db.triwizardChapters.get(chapterId);
            let slotsHtml = '';
            for (let i = 0; i < 3; i++) {
                const slot = chapter.savedSlots[i];
                const isMain = chapter.mainSaveSlotIndex === i;
                const slotInfo = slot ? `存档于: ${new Date(slot.timestamp).toLocaleString()}` : '空记录';
                const mainTag = isMain ? '<span class="main-record-tag">主要记录</span>' : '';
                slotsHtml += `
                    <div class="save-slot-item">
                        <label>
                            <input type="radio" name="main-save-slot" value="${i}" ${isMain ? 'checked' : ''} style="width: 20px; height: 20px;">
                            <div class="save-slot-info">
                                <strong>记录槽 ${i + 1}</strong>
                                <span style="font-size: 12px; opacity: 0.8;">${slotInfo}</span>
                                ${mainTag}
                            </div>
                        </label>
                        <button class="btn primary" data-slot-index="${i}" style="padding: 5px 10px; font-size: 14px;">存档</button>
                    </div>
                `;
            }
            slotsHtml += `
                <div class="save-slot-item">
                    <label>
                        <input type="radio" name="main-save-slot" value="-1" ${chapter.mainSaveSlotIndex === -1 ? 'checked' : ''} style="width: 20px; height: 20px;">
                        <div class="save-slot-info">
                            <strong>暂不确定主要存档</strong>
                            <span style="font-size: 12px; opacity: 0.8;">AI将不会读取本章的任何记录</span>
                        </div>
                    </label>
                </div>
            `;
            showDialog(`
                <div class="dialog-title">保存剧情记录</div>
                <p style="text-align: center; font-size: 14px; margin-bottom: 15px;">选择一个记录槽进行覆盖，并指定一个作为AI记忆的【主要记录】。</p>
                ${slotsHtml}
                <div class="dialog-actions">
                    <button class="dialog-btn" id="confirmSaveSettings">确认设置</button>
                </div>
            `);
            
            document.querySelectorAll('.save-slot-item .btn').forEach(button => {
                button.onclick = async (e) => {
                    const slotIndex = parseInt(e.currentTarget.dataset.slotIndex);
                    if (confirm(`确定要覆盖记录槽 ${slotIndex + 1} 吗？`)) {
                        chapter.savedSlots[slotIndex] = {
                            messages: JSON.parse(JSON.stringify(state.currentChat.messages)),
                            timestamp: Date.now()
                        };
                        await db.triwizardChapters.put(chapter);
                        alert(`已成功保存至记录槽 ${slotIndex + 1}！`);
                        hideDialog();
                        showSaveStoryDialog(chapterId);
                    }
                };
            });
            document.getElementById('confirmSaveSettings').onclick = async () => {
                const selectedRadio = document.querySelector('input[name="main-save-slot"]:checked');
                if (!selectedRadio) {
                    return alert("请选择一个主要记录选项！");
                }
                const newMainIndex = parseInt(selectedRadio.value);
                if (newMainIndex !== -1 && !chapter.savedSlots[newMainIndex]) {
                    return alert("不能将一个空的记录槽设为主要记录！请先存档。");
                }
                chapter.mainSaveSlotIndex = newMainIndex;
                await db.triwizardChapters.put(chapter);
                alert("主要记录设置已更新！");
                hideDialog();
            };
        }
        async function moveContactToGroup(contactId, newGroupId) {
            state.groups.forEach(group => {
                const index = group.contactIds.indexOf(contactId);
                if (index > -1) {
                    group.contactIds.splice(index, 1);
                }
            });
            if (newGroupId !== 'ungrouped') {
                const newGroup = state.groups.find(g => g.id === newGroupId);
                if (newGroup) {
                    newGroup.contactIds.push(contactId);
                }
            }
            await db.groups.bulkPut(state.groups);
            renderGroupedContacts();
        }
        function showContextMenu(e, type, id, commentIndex) {
            let items = '';
            
            if (type === 'message') {
                const msg = state.currentChat.messages.find(m => m.id === id); if (!msg) return;
                items = `<div class="context-menu-item" data-action="quote">引用</div>`;
                if (msg.type === 'text' || msg.type === undefined) {
                     items += `<div class="context-menu-item" data-action="modify">修改</div>`;
                }
                items += `<div class="context-menu-item" data-action="delete">删除</div>`;
            } 
            else if (type === 'chatItem') {
                const chat = state.chats.find(c => c.id === id); if (!chat) return;
                const pinAction = chat.isPinned ? 'unpinChat' : 'pinChat';
                const pinText = chat.isPinned ? '取消置顶' : '置顶';
                items = `<div class="context-menu-item" data-action="${pinAction}">${pinText}</div>`;
                items += `<div class="context-menu-item" data-action="deleteChat">删除</div>`;
            }
            else if (type === 'groupChatItem') {
                const chat = state.chats.find(c => c.id === id); if (!chat) return;
                const pinAction = chat.isPinned ? 'unpinChat' : 'pinChat';
                const pinText = chat.isPinned ? '取消置顶' : '置顶';
                items = `<div class="context-menu-item" data-action="${pinAction}">${pinText}</div>`;
                if (state.currentView === 'contacts') {
                    items += `<div class="context-menu-item" data-action="deleteGroup">删除群聊</div>`;
                } else {
                    items += `<div class="context-menu-item" data-action="deleteChat">删除</div>`;
                }
            }
            else if (type === 'friendItem') {
                const contact = state.contacts.find(c => c.id === id); if (!contact) return;
                const pinAction = contact.isPinned ? 'unpinContact' : 'pinContact';
                const pinText = contact.isPinned ? '取消置顶' : '置顶';
                items = `<div class="context-menu-item" data-action="${pinAction}">${pinText}</div>
                         <div class="context-menu-item" data-action="showMoveToGroupDialog">移动到...</div>`;
            }
             else if (type === 'manageGroupHeader') {
                const group = state.groups.find(g => g.id === id); if (!group) return;
                const pinText = group.isPinned ? '取消置顶' : '置顶';
                 items = `<div class="context-menu-item" data-action="renameGroup">重命名</div>
                         <div class="context-menu-item" data-action="pinGroup">${pinText}</div>
                         <div class="context-menu-item" data-action="deleteGroupHeader">删除</div>`;
            }
            else if (type === 'moment' || type === 'comment') {
                items += `<div class="context-menu-item" data-action="delete">删除</div>`;
            }
            contextMenu.innerHTML = items;
            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.classList.remove('hidden');
            
            contextMenu.querySelector('[data-action="showMoveToGroupDialog"]')?.addEventListener('click', () => {
                showMoveToGroupDialog(id);
                contextMenu.classList.add('hidden');
            });
            contextMenu.querySelector('[data-action="renameGroup"]')?.addEventListener('click', () => {
                const group = state.groups.find(g => g.id === id);
                if (group) showGroupRenameDialog(id);
                contextMenu.classList.add('hidden');
            });
            contextMenu.querySelector('[data-action="pinGroup"]')?.addEventListener('click', async () => {
                const group = state.groups.find(g => g.id === id);
                if (group) {
                    group.isPinned = !group.isPinned;
                    await db.groups.put(group);
                    showManageGroupsDialog();
                    renderGroupedContacts();
                }
                contextMenu.classList.add('hidden');
            });
            contextMenu.querySelector('[data-action="deleteGroupHeader"]')?.addEventListener('click', async () => {
                const group = state.groups.find(g => g.id === id);
                if (group) {
                    if (confirm(`确认删除分组 “${group.name}” 吗？\n分组内的好友将变为未分组。`)) {
                        await db.groups.delete(id);
                        state.groups = state.groups.filter(g => g.id !== id);
                        showManageGroupsDialog();
                        renderGroupedContacts();
                    }
                }
                contextMenu.classList.add('hidden');
            });
            contextMenu.querySelector('[data-action="delete"]')?.addEventListener('click', () => { 
                if (type === 'comment') deleteComment(id, commentIndex);
                else if (type === 'moment') deleteMoment(id);
                else if (type === 'message') deleteMessage(id);
                contextMenu.classList.add('hidden'); 
            });
            contextMenu.querySelector('[data-action="quote"]')?.addEventListener('click', async () => { const msg = state.currentChat.messages.find(m => m.id === id); state.replyingTo = { sender: msg.sender, text: msg.text }; await updateAppState(); document.getElementById('messageInput').focus(); contextMenu.classList.add('hidden'); });
            contextMenu.querySelector('[data-action="modify"]')?.addEventListener('click', () => { modifyMessage(id); contextMenu.classList.add('hidden'); });
            
            contextMenu.querySelector('[data-action="pinChat"]')?.addEventListener('click', async () => { 
                const chat = state.chats.find(c=>c.id===id); if(chat) chat.isPinned = true; await db.chats.put(chat);
                if (state.currentView === 'contacts') renderGroupsList(); else switchView('messages', true);
                contextMenu.classList.add('hidden'); 
            });
            contextMenu.querySelector('[data-action="unpinChat"]')?.addEventListener('click', async () => { 
                const chat = state.chats.find(c=>c.id===id); if(chat) chat.isPinned = false; await db.chats.put(chat);
                if (state.currentView === 'contacts') renderGroupsList(); else switchView('messages', true);
                contextMenu.classList.add('hidden'); 
            });
            contextMenu.querySelector('[data-action="pinContact"]')?.addEventListener('click', async () => { 
                const contact = state.contacts.find(c=>c.id===id); if(contact) contact.isPinned = true; await db.contacts.put(contact);
                if (state.currentView === 'contacts') renderGroupedContacts();
                contextMenu.classList.add('hidden'); 
            });
             contextMenu.querySelector('[data-action="unpinContact"]')?.addEventListener('click', async () => { 
                const contact = state.contacts.find(c=>c.id===id); if(contact) contact.isPinned = false; await db.contacts.put(contact);
                if (state.currentView === 'contacts') renderGroupedContacts();
                contextMenu.classList.add('hidden'); 
            });
            contextMenu.querySelector('[data-action="deleteChat"]')?.addEventListener('click', () => { showDeleteChatDialog(id); contextMenu.classList.add('hidden'); });
            contextMenu.querySelector('[data-action="deleteGroup"]')?.addEventListener('click', () => { deleteGroupChat(id); contextMenu.classList.add('hidden'); });
        }
        function showDeleteChatDialog(id) {
            const dialogHtml = `
                <div class="dialog-title">确认删除</div>
                <p style="text-align: center; margin-bottom: 20px;">请选择删除方式：</p>
                <div class="dialog-actions" style="flex-direction: column; gap: 10px; align-items: stretch;">
                    <button class="dialog-btn" id="deleteChatSoft">仅从列表移除 (保留记录)</button>
                    <button class="dialog-btn logout" id="deleteChatHard">清空全部聊天记录 (不可恢复)</button>
                </div>
            `;
            showDialog(dialogHtml);
            document.getElementById('deleteChatSoft').onclick = async () => {
                const chat = state.chats.find(c => c.id === id);
                if (chat) chat.isHidden = true;
                await db.chats.put(chat);
                hideDialog();
                switchView('messages', true);
            };
            document.getElementById('deleteChatHard').onclick = async () => {
                const chat = state.chats.find(c => c.id === id);
                if (chat) {
                    chat.messages = [];
                    chat.lastMessage = '可以开始聊天了';
                    chat.isHidden = true;
                }
                await db.chats.put(chat);
                hideDialog();
                switchView('messages', true);
            };
        }
        async function deleteMessage(id) { 
            const index = state.currentChat.messages.findIndex(m=>m.id===id); 
            if (index > -1) { 
                state.currentChat.messages.splice(index, 1);
                if (!state.currentChat.isTriwizard) {
                    await db.chats.put(state.currentChat);
                }
                switchView('chat', true);
            }
        }
        async function modifyMessage(id) { 
            const msg = state.currentChat.messages.find(m => m.id === id); 
            if(!msg || (msg.type && msg.type !== 'text')) return alert("只能修改文本消息"); 
            const dialogHtml = `
                <div class="dialog-title">修改消息</div>
                <div class="form-group">
                    <textarea id="dialog-edit-input" rows="4" style="-webkit-user-select: text; user-select: text;">${msg.text}</textarea>
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn cancel-btn" id="dialog-edit-cancel">取消</button>
                    <button class="dialog-btn" id="dialog-edit-save">保存</button>
                </div>
            `;
            showDialog(dialogHtml);
            
            document.getElementById('dialog-edit-save').onclick = async () => {
                const newText = document.getElementById('dialog-edit-input').value;
                msg.text = newText;
                if (!state.currentChat.isTriwizard) {
                    await db.chats.put(state.currentChat);
                }
                hideDialog();
                switchView('chat', true);
            };
            document.getElementById('dialog-edit-cancel').onclick = hideDialog;
        }
        async function deleteMoment(id) { let index = (state.myMoments||[]).findIndex(m=>m.id===id); if(index > -1) { state.myMoments.splice(index, 1); await db.myMoments.delete(id); } else { index = (state.friendMoments||[]).findIndex(m=>m.id===id); if(index > -1) { state.friendMoments.splice(index, 1); await db.friendMoments.delete(id); }} switchView('moments', true); }
        async function deleteComment(momentId, commentIndex) {
            const isMyMoment = state.myMoments.some(m => m.id === momentId);
            const moment = isMyMoment ? state.myMoments.find(m => m.id === momentId) : state.friendMoments.find(m => m.id === momentId);
            if (moment && moment.comments && moment.comments[commentIndex]) {
                moment.comments.splice(commentIndex, 1);
                if (isMyMoment) await db.myMoments.put(moment);
                else await db.friendMoments.put(moment);
                switchView('moments', true);
            }
        }
        
        function messageToText(msg) {
            if (state.currentChat.isTriwizard) {
                const sender = msg.incoming ? (msg.sender || '旁白') : state.userProfile.name;
                return `${sender}: ${msg.text}`;
            }
            const senderName = msg.incoming ? msg.sender : (state.currentChat.myNickname || msg.sender);
            if (state.currentChat.isGroup) {
                if (state.currentChat.isOfflineMode && !msg.incoming) {
                    return `(${senderName} ${msg.text})`;
                }
                return `${senderName}: ${msg.text}`;
            }
            switch(msg.type) {
                case 'image': return `[我发了一张图片，描述是：“${msg.text || '无'}”]`;
                case 'emoji': return `<${msg.id}>`;
                case 'gift': 
                    const recipient = msg.gift.recipient ? ` to ${msg.gift.recipient}` : '';
                    return `[我送了你一个礼物：“${msg.gift.name}”${recipient}，心意是：“${msg.gift.message || '无'}”]`;
                case 'text': return msg.quote ? `(回复 ${msg.quote.sender}: "${msg.quote.text}") ${msg.text}` : msg.text || "";
                default: return `[一条${msg.type}类型的消息]`;
            }
        }
        
        async function fetchApiModels(config) {
            const { url, key } = config;
            if (!url || !key) throw new Error("API URL 和 Key 不能为空");
            
            let fetchUrl, headers;
            if (url.includes('generativelanguage.googleapis.com')) {
                fetchUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                headers = { 'Content-Type': 'application/json' };
            } else {
                const baseUrl = new URL(url.replace(/\/$/, ''));
                fetchUrl = new URL('/v1/models', baseUrl).href;
                headers = { 'Authorization': `Bearer ${key}` };
            }
            try {
                const res = await fetch(fetchUrl, { headers });
                const data = await res.json();
                if (!res.ok) {
                    const errorMsg = data.error?.message || `服务器返回错误: ${res.status}`;
                    throw new Error(errorMsg);
                }
                if (url.includes('generativelanguage.googleapis.com')) {
                    return data.models
                        .filter(m => m.supportedGenerationMethods.includes('generateContent'))
                        .map(m => m.name.replace('models/', ''));
                } else {
                    return data.data.map(m => m.id);
                }
            } catch (error) {
                if (error instanceof TypeError) {
                    throw new Error("网络请求失败 (可能是CORS跨域问题或URL无效)");
                }
                throw error;
            }
        }
        
        async function callApi(systemPrompt, history = [], config = state.apiConfig) {
            const { url, key, model } = config;
            if (!url || !key || !model) {
                throw new Error("API URL, Key, 和模型名称未配置。");
            }
            
            try {
                let res, data;
                const processedHistory = history.map(m => ({
                    role: m.incoming ? 'model' : 'user',
                    content: messageToText(m)
                })).filter(m => m.content);
                
                const maxTokens = 400;
                if (url.includes('generativelanguage.googleapis.com')) {
                    const baseUrl = new URL(url);
                    const fullUrl = new URL(`v1beta/models/${model}:generateContent?key=${key}`, baseUrl).href;
                    const contents = [
                        { role: 'user', parts: [{ text: systemPrompt }] },
                        { role: 'model', parts: [{ text: "好的，我明白了。我会严格遵守所有指令进行角色扮演。" }] }
                    ].concat(processedHistory.map(m => ({ role: m.role, parts: [{ text: m.content }] })));
                    
                    res = await fetch(fullUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents, generationConfig: {maxOutputTokens: maxTokens} }) });
                    data = await res.json();
                    
                    if (!res.ok) throw new Error(data.error?.message || `HTTP ${res.status}`);
                    if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content.parts) return "(API返回了空响应或不完整的数据)";
                    return data.candidates[0].content.parts[0].text.trim();
                } else {
                    const baseUrl = new URL(url.replace(/\/$/, ''));
                    const completionUrl = new URL('/v1/chat/completions', baseUrl).href;
                    const headers = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${key}`
                    };
                    const messages = [
                        { role: "system", content: systemPrompt },
                        ...processedHistory.map(m => ({ 
                            role: m.role === 'model' ? 'assistant' : 'user', 
                            content: m.content
                        }))
                    ];
                    
                    res = await fetch(completionUrl, { method: 'POST', headers, body: JSON.stringify({ model: model, messages: messages, max_tokens: maxTokens }) });
                    data = await res.json();
                    
                    if (!res.ok) throw new Error(data.error?.message || `未知的API错误 (HTTP ${res.status})`);
                    if (!data.choices || data.choices.length === 0) return "(API返回了空响应)";
                    return data.choices[0].message.content.trim();
                }
            } catch (error) {
                if (error instanceof TypeError) {
                    throw new Error("网络请求失败 (可能是CORS跨域问题或URL格式错误)");
                }
                throw error;
            }
        }
        
        function parseHogwartsResponse(content) {
            const trimmedContent = content.trim();
            if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                try {
                    const parsed = JSON.parse(trimmedContent);
                    if (Array.isArray(parsed) && parsed.every(item => typeof item === 'object' && item !== null && 'name' in item && 'content' in item)) {
                         console.log("解析成功：标准JSON数组格式(群聊/三强赛)。");
                         return parsed.map(p => ({ ...p, type: 'text' }));
                    }
                } catch (e) {
                    console.warn("标准JSON数组解析失败，将尝试强力解析...");
                }
            }
            const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
            if (jsonMatches) {
                const results = [];
                for (const match of jsonMatches) {
                    try {
                        const parsedObject = JSON.parse(match);
                        if ('name' in parsedObject && 'content' in parsedObject) {
                             results.push({ ...parsedObject, type: 'text' });
                        } else if ('type' in parsedObject && 'content' in parsedObject) {
                             results.push(parsedObject);
                        }
                    } catch (e) {
                        console.warn("跳过一个无效的JSON片段:", match);
                    }
                }
                if (results.length > 0) {
                    console.log("解析成功：通过强力提取JSON对象模式。");
                    return results;
                }
            }
            
            const legacyMatches = [...trimmedContent.matchAll(/\[([^\]]+)\]|<([^>]+)>/g)];
            if (legacyMatches.length > 0) {
                 console.log("解析成功：通过旧版格式兼容模式。");
                 return legacyMatches.map(match => {
                    if (match[1]) return { type: 'text', content: match[1] };
                    if (match[2]) return { type: 'emoji', id: match[2] };
                 }).filter(Boolean);
            }
            console.error("所有解析方案均失败！将返回原始文本作为单条消息。");
            return [{ type: 'text', content: content }];
        }
        async function generateUnifiedHistoryText(contactId, totalLimit = 50) {
            if (!contactId) return "";
            const contact = state.contacts.find(c => c.id === contactId);
            if (!contact) return "";
            
            const allEvents = [];
            const p = state.userProfile;
        
            const privateChat = state.chats.find(c => c.contactId === contactId);
            if (privateChat && privateChat.messages) {
                privateChat.messages.forEach(m => {
                    if (!m.id || !m.id.includes('_')) return;
                    allEvents.push({
                        timestamp: parseInt(m.id.split('_')[1]),
                        text: `[私聊] ${m.incoming ? contact.name : p.name}: ${m.type === 'text' || !m.type ? m.text : `[${m.type}消息]`}`
                    });
                });
            }
        
            const groupChats = state.chats.filter(c => c.isGroup && c.members.some(m => m.id === contactId));
            groupChats.forEach(group => {
                if (group.messages) {
                    group.messages.forEach(m => {
                         if (!m.id || !m.id.includes('_')) return;
                         allEvents.push({
                            timestamp: parseInt(m.id.split('_')[1]),
                            text: `[群聊: ${group.name}] ${m.sender}: ${m.type === 'text' || !m.type ? m.text : `[${m.type}消息]`}`
                        });
                    });
                }
            });
            try {
                const recentMoments = await db.myMoments.orderBy('id').reverse().limit(10).toArray();
                const recentFriendMoments = await db.friendMoments.orderBy('id').reverse().limit(20).toArray();
                
                recentMoments.forEach(moment => {
                    const hasInteraction = (moment.likedBy && moment.likedBy.includes(contact.name)) || (moment.comments && moment.comments.some(c => c.author === contact.name));
                    if(hasInteraction){
                        let interactionSummary = (moment.comments || []).filter(c => c.author === contact.name).map(c => `${c.author}: ${c.text}`).join('; ');
                        if((moment.likedBy || []).includes(contact.name)) interactionSummary = "[赞] " + interactionSummary;
                        allEvents.push({
                            timestamp: parseInt(moment.id.split('_')[1]),
                            text: `[动态互动] 你发布了动态: "${moment.content}". ${contact.name} 回应: ${interactionSummary}`
                        });
                    }
                });
                recentFriendMoments.forEach(moment => {
                    if(moment.name === contact.name) {
                        allEvents.push({
                           timestamp: parseInt(moment.id.split('_')[1]),
                           text: `[动态发布] ${contact.name} 发布了动态: "${moment.content}"`
                        });
                    }
                });
            } catch (e) { console.error("Failed to fetch moments for memory:", e); }
        
            const sortedEvents = allEvents.sort((a, b) => b.timestamp - a.timestamp);
            const recentHistory = sortedEvents.slice(0, totalLimit).reverse();
        
            if (recentHistory.length === 0) {
                return "最近没有与此人相关的互动记录。";
            }
            
            return recentHistory.map(m => m.text).join('\n\n');
        }
        async function getTriwizardMemoryPool() {
            try {
                const allChapters = await db.triwizardChapters.toArray();
                if (!allChapters || allChapters.length === 0) return "";
        
                let memoryPoolText = "";
                for (const chapter of allChapters) {
                    if (chapter.mainSaveSlotIndex > -1 && chapter.savedSlots[chapter.mainSaveSlotIndex]) {
                        const mainSave = chapter.savedSlots[chapter.mainSaveSlotIndex];
                        const chapterHistory = mainSave.messages
                            .map(msg => {
                                const sender = msg.incoming ? (msg.sender || '旁白') : state.userProfile.name;
                                return `${sender}: ${msg.text}`;
                            })
                            .join('\n');
                        memoryPoolText += `--- 章节《${chapter.name}》的主要记忆 ---\n${chapterHistory}\n\n`;
                    }
                }
                return memoryPoolText.trim() || "玩家尚未在任何三强争霸赛章节中设定主要存档。";
            } catch (error) {
                console.error("Error building Triwizard memory pool:", error);
                return "（读取三强争霸赛记忆时发生错误）";
            }
        }
        async function getApiResponse(mode = "reply") {
            const historyEl = document.getElementById('chatHistory');
            const scroll = () => { if(historyEl) historyEl.scrollTop = historyEl.scrollHeight; };
            const isGroup = state.currentChat.isGroup;
            const isTriwizard = state.currentChat.isTriwizard;
            const contact = isGroup || isTriwizard ? null : state.contacts.find(c => c.id === state.currentChat.contactId);
            const contactName = isGroup ? state.currentChat.name : (isTriwizard ? "剧情" : contact.name);
            
            const showError = async (text) => {
                const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                const reply = { id: `msg_${Date.now()}`, type:'text', text, time, incoming: true, sender: "系统" };
                state.currentChat.messages.push(reply);
                if(historyEl) {
                    const errorEl = document.createElement('div');
                    errorEl.className = 'message incoming';
                    errorEl.innerHTML = `<div class="message-sender">系统</div><div class="message-text">${text}</div><span class="message-time">${time}</span>`;
                    historyEl.appendChild(errorEl);
                    scroll();
                }
                if (!isTriwizard) await updateChatList(text, true);
            };
            if (!state.apiConfig.key) {
                await showError("（API未配置，请在“我”的页面设置）");
                return;
            }
            const typingEl = document.createElement('div');
            typingEl.className = 'message incoming';
            typingEl.innerHTML = `<div class="message-sender">${contactName}</div><div style="padding: 8px 15px;"><div style="width: 8px; height: 8px; background-color: #f0e6d2; border-radius: 50%; display:inline-block; animation: typing 1.5s infinite ease-in-out;"></div> <div style="width: 8px; height: 8px; background-color: #f0e6d2; border-radius: 50%; display:inline-block; animation: typing 1.5s infinite ease-in-out 0.15s;"></div> <div style="width: 8px; height: 8px; background-color: #f0e6d2; border-radius: 50%; display:inline-block; animation: typing 1.5s infinite ease-in-out 0.3s;"></div></div>`;
            if(historyEl) { historyEl.appendChild(typingEl); scroll(); }
            const p = state.userProfile;
            const triwizardMemoryPool = await getTriwizardMemoryPool();
            
            let systemPrompt;
            const isOffline = !!state.currentChat.isOfflineMode;
            if (isTriwizard) {
                systemPrompt = `你是一个互动小说游戏的主持人（Game Master），需要扮演多个角色。
# 游戏背景：
哈利波特世界，三强争霸赛期间。
# 玩家信息：
姓名: ${p.name} (姓: ${p.lastName}, 名: ${p.firstName})
学院: ${HOUSE_INFO[p.house].name}
性格: ${p.personality}
# 游戏总记忆 (来自玩家在所有章节中选择的主要存档):
${triwizardMemoryPool}
# 你的任务：
1.  **多角色扮演**：你将扮演【除了玩家以外】的所有角色，包括但不限于哈利·波特、赫敏、罗恩、马尔福、斯内普、邓布利多等。
2.  **扮演旁白**：当需要描述群体行为、景物、气氛或非特定角色的动作时，你将使用 “旁白” 作为角色名。旁白应使用第二人称“你”来与玩家互动。
3.  **推动剧情**：根据玩家的行动和对话，以及总记忆中的内容，自然地推进故事发展。
4.  **维持世界观**：严格遵守哈利波特的世界观和所有角色的既定人设，【绝对不能崩人设】。
5.  **互动要求**：每一次回复，应至少有【五个】角色（包括“旁白”）进行发言或行动描述，以营造丰富的互动场景。
# ***最最最重要的输出规则 (ABSOLUTE MANDATORY RULES)***
1.  **【格式铁则】**: 你的回复【必须】是一个JSON数组格式的字符串。例如: \`[{"name": "旁白", "content": "你走进了大厅。"}, {"name": "赫敏·格兰杰", "content": "你终于来了！"}, {"name": "罗恩·韦斯莱", "content": "我们等你很久了。"}]\`
2.  **【元素铁则】**: 数组中的【每一个元素都必须是一个JSON对象】，且【必须】包含 "name" 和 "content" 两个字段。
3.  **【禁止】**: 【绝对禁止】在JSON数组之外输出任何其他文字、解释或注释。
4.  **【禁止】**: 【绝对禁止】扮演玩家（${p.name}）的角色。
现在，请严格按照上述【所有铁则】，根据下方的最新对话历史，继续这个故事。`;
            }
            else if(isGroup) {
                const myNickname = state.currentChat.myNickname || p.name;
                const membersListPromises = state.currentChat.members.map(async m => {
                    const contact = state.contacts.find(c => c.id === m.id);
                    const persona = m.persona || (contact ? contact.info : '');
                    const history = contact ? (contact.sharedHistory || '无共同记忆') : '无共同记忆';
                    const recentChatHistory = contact ? await generateUnifiedHistoryText(contact.id) : '无相关聊天记录';
                    const indentedRecentHistory = recentChatHistory.split('\n').map(line => `    ${line}`).join('\n');
                    const displayName = m.nickname || m.name;
                    if (!persona || persona.trim() === '') {
                        return `- **${displayName}** (原名: ${m.name}):\n  - 人设: (无可用人设，该角色不会发言)`;
                    }
                    return `- **${displayName}** (原名: ${m.name}):
    - 人设: ${persona}
    - 和玩家的长期记忆: ${history}
    - 最近的跨聊天/事件记录:
${indentedRecentHistory}`;
                });
                const membersList = (await Promise.all(membersListPromises)).join('\n');
                
                if (isOffline) {
                    systemPrompt = `你是一个群聊场景的AI叙事者。
# 核心规则
1.  **【叙事者身份】**: 你不是任何一个角色，而是上帝视角的叙事者/剧本作者。你的任务是生动地描绘【除了玩家以外】所有角色的【语言、动作、神态、心理活动、场景】。
2.  **【玩家身份】**: 玩家的角色是【${myNickname}】。你【绝对不能】替玩家做任何决定或描写。所有对玩家的描述都应使用第二人称“你”。
3.  **【输出格式】**: 你的回复【必须】是一个【单一的、连续的文本块】。所有非对话内容【必须】用中文括号（）括起来。对话内容则不需要括号，但【必须】在对话前明确标注说话者的姓名或昵称。例如: \`德拉科: “这真是荒谬。”（他轻轻地哼了一声。）\`
4.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
5.  **禁止出戏**: 绝不能透露你是AI、模型或叙事者。
# 群成员列表及人设
${membersList}
# 玩家的角色
- **${myNickname}** (原名: ${p.name}): ${p.personality}
# 会话概要 (玩家手动总结):
${state.currentChat.summary || "暂无概要。"}
# (背景信息) 三强争霸赛主要记忆:
${triwizardMemoryPool}
现在，请根据以上所有规则和下方的对话历史，继续这场线下群聊场景。`;
                } else {
                    systemPrompt = `你是一个群聊AI，负责扮演【除了玩家以外】的所有角色。
# 核心规则
1.  **【身份铁律】**: 玩家的身份是【${myNickname}】。你【绝对不能】生成 name 字段为 "${myNickname}" 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。
2.  **【输出格式】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "name" 和 "content" 字段的JSON对象】。name字段必须是角色的【群昵称（如果存在）或原名】。例如: \`[{"name": "马尔福", "content": "这真是荒谬。"}, {"name": "赫敏·格兰杰", "content": "德拉科,注意你的言辞！"}]\`
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定，尤其是他们的长期和短期记忆。
4.  **禁止出戏**: 绝不能透露你是AI或模型。
5.  **【发言资格】**: 你只能为那些在下方列表中拥有明确“人设”的角色生成发言。如果一个角色的人设是“(无可用人设...)"，则【绝对不能】为该角色生成任何发言。
# 群成员列表及人设
${membersList}
# 玩家的角色
- **${myNickname}** (原名: ${p.name}): ${p.personality}
# 会话概要 (玩家手动总结):
${state.currentChat.summary || "暂无概要。"}
# (背景信息) 三强争霸赛主要记忆:
${triwizardMemoryPool}
现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
                }
            } else {
                let playerAddressName = '';
                const isProfessor = contact.id.startsWith('prof');
                if (isProfessor) {
                    playerAddressName = p.lastName ? (p.gender === '女' ? `${p.lastName}小姐` : `${p.lastName}先生`) : p.name;
                } else {
                    playerAddressName = p.firstName || p.name;
                }
                const wandInfo = `木材: ${p.wand.wood}, 杖芯: ${p.wand.core}, 长度: ${p.wand.length}, 柔韧度: ${p.wand.flex}`;
                const customEmojis = p.customEmojis || {};
                const emojiListString = Object.entries(customEmojis).map(([id, data]) => `${id}：${data.name}`).join('\n');
                
                const recentChatHistory = await generateUnifiedHistoryText(contact.id);
                
                let modeInstructions = '';
                let outputRules = '';
                if (isOffline) {
                    modeInstructions = `# 当前模式：线下模式
    你和我的交流处于【线下模式】，请用剧本体回复。`;
                    outputRules = `# ***最最最重要的输出规则 (ABSOLUTE MANDATORY RULES)***
    你接下来的每一次回复都【必须】严格遵守以下所有规则，没有任何例外！
    1.  **【内容核心】**: 你的回复必须是详细且优美的【语言、动作、神态、心理活动、场景描写】的结合。
    2.  **【格式】**: 所有非对话内容【必须】用中文括号（）括起来。对话内容则不需要括号。非对话内容与对话内容之间【必须】另起一段。
    3.  **【人称】**: 对于你自己，【必须】使用第一人称“我”。对于我（玩家），【必须】使用第二人称“你”。例如：（我轻轻拉起了你的手。）
    4.  **【长度铁则】**: 你的总回复内容【必须超过100字】。这是为了保证描写的丰富性。**【绝对禁止】** 生成少于100字的总回复。
    5.  **【输出格式】**: **【严禁】** 将你的回复拆分成多条消息。你必须生成一个【单一的、连续的文本块】作为回复。
    6.  **【禁止】**: 【严禁】使用表情包或任何JSON格式。`;
                } else {
                    modeInstructions = `# 当前模式：线上模式
    你和我的交流处于【线上模式】，请像使用聊天软件一样回复。`;
                    outputRules = `# ***最最最重要的输出规则 (ABSOLUTE MANDATORY RULES)***
    你接下来的每一次回复都【必须】严格遵守以下所有规则，没有任何例外！
    1.  **【格式铁则】**: 你的回复【必须】是一个JSON数组格式的字符串。例如: \`[{"type":"text", "content":"你好呀！"}, {"type":"text", "content":"今天天气真不错"}]\`
    2.  **【元素铁则】**: 数组中的【每一个元素都必须是一个JSON对象】。
    3.  **【对话节奏铁则】**: 你的回复【必须】严格遵守总数50字左右，且必须分成【三条及以上】独立消息的格式发出。单条消息应简短精炼。例如，不要发一条长消息 \`[{"type":"text", "content":"你好呀，今天天气真不错，我们一起出去玩吧怎么样？"}]\`，而是要拆分成 \`[{"type":"text", "content":"你好呀！"}, {"type":"text", "content":"今天天气真不错"}, {"type":"text", "content":"我们出去玩吧？"}]\`。
    4.  **【禁止】**: 【绝对禁止】输出任何括号内的动作、神态、心理或场景描写。所有回复都应是角色会直接通过聊天软件说出的话。
    5.  **【禁止】**: 【绝对禁止】在JSON数组之外输出任何其他文字、解释或注释。
    ## 你可以使用的操作指令 (JSON数组中的元素):
    -   **发送文本**: \`{"type": "text", "content": "消息内容"}\`
    -   **发送表情**: \`{"type": "emoji", "id": "表情包ID"}\` (ID必须从下面的列表中选择)
    # 可用表情包列表:
    ${emojiListString || '(无可用表情包)'}`;
                }
                systemPrompt = `你正在扮演《哈利·波特》世界中的角色。
    ${modeInstructions}
    # 你的角色信息:
    姓名: ${contact.name}
    ${contact.info}
    # 你正在与我对话，我的角色信息 (巫师档案):
    姓名: ${p.name} (姓: ${p.lastName}, 名: ${p.firstName}) 性别: ${p.gender} 年龄: ${p.age || '未知'} 学院: ${HOUSE_INFO[p.house].name} 血统: ${p.blood} 魔杖: ${wandInfo} 守护神: ${p.patronus} 宠物: ${p.pet} 外貌: ${p.appearance} 性格: ${p.personality} 身份背景: ${p.identity}
    # 我们之间发生过以下事情 (共同经历 - 长期记忆):
    ${contact.sharedHistory || "我们是刚认识的同学。"}
    # 最近的跨聊天/事件记录 (自动提取 - 短期记忆):
    ${recentChatHistory}
    # 会话概要 (当前聊天手动总结):
    ${state.currentChat.summary || "暂无概要。"}
    # (背景信息) 三强争霸赛主要记忆:
    ${triwizardMemoryPool}
    # 重要称呼规则:
    你应该称呼我为“${playerAddressName}”。除非语境特殊需要，否则请避免使用我的全名“${p.name}”。
    ${outputRules}
    # 通用规则:
    **【禁止代入】**: 【严禁】代入玩家（“${p.name}”）的角色发言或进行心理描写。
    现在，请严格按照上述【所有铁则】，基于对话历史，生成你的回复。`;
            }
            const historyForApi = state.currentChat.messages.slice(-150);
            
            try {
                const rawReply = await callApi(systemPrompt, historyForApi);
                if(historyEl && historyEl.contains(typingEl)) historyEl.removeChild(typingEl);
                
                if (isTriwizard) {
                    const responseActions = parseHogwartsResponse(rawReply);
                    const newMessages = [];
                    for (const action of responseActions) {
                        const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                        if (action.name && action.content) {
                            newMessages.push({ id: `msg_${Date.now()}_${newMessages.length}`, type: 'text', text: action.content, time, incoming: true, sender: action.name });
                        }
                    }
                    if (newMessages.length > 0) {
                        state.currentChat.messages.push(...newMessages);
                        switchView('chat', true);
                    } else {
                        await showError("（魔法通讯受到了干扰... AI返回了无法解析或空的内容。）");
                    }
                }
                else if(isGroup && isOffline) {
                    if (rawReply) {
                        const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                        const reply = { id: `msg_${Date.now()}`, type:'text', text: rawReply, time, incoming: true, sender: "场景" };
                        state.currentChat.messages.push(reply);
                        await updateChatList("[场景描述]", true);
                        switchView('chat', true);
                    } else {
                        await showError("（魔法通讯受到了干扰...）");
                    }
                }
                else if(isGroup) {
                    const responseActions = parseHogwartsResponse(rawReply);
                    const newMessages = [];
                    for (const action of responseActions) {
                         const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                         if (action.name && action.content) {
                            newMessages.push({ id: `msg_${Date.now()}_${newMessages.length}`, type: 'text', text: action.content, time, incoming: true, sender: action.name });
                         }
                    }
                    state.currentChat.messages.push(...newMessages);
                    await updateChatList(newMessages.length > 0 ? `${newMessages[newMessages.length-1].sender}: ${newMessages[newMessages.length-1].text}` : '...', true);
                    switchView('chat', true);
                }
                else if (isOffline) {
                    if (rawReply) {
                        const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                        const reply = { id: `msg_${Date.now()}`, type:'text', text: rawReply, time, incoming: true, sender: contact.name };
                        state.currentChat.messages.push(reply);
                        await updateChatList(rawReply, true);
                        switchView('chat', true);
                    } else {
                        await showError("（魔法通讯受到了干扰...）");
                    }
                } else {
                    const responseActions = parseHogwartsResponse(rawReply);
                    if (responseActions.length > 0) {
                        const newMessages = [];
                        for (const action of responseActions) {
                            const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                            if (action.type === 'text' && action.content) { 
                                newMessages.push({ id: `msg_${Date.now()}_${newMessages.length}`, type: 'text', text: action.content, time, incoming: true, sender: contact.name });
                            } else if (action.type === 'emoji' && action.id) {
                                const emojiData = (state.userProfile.customEmojis || {})[action.id];
                                if (emojiData) {
                                    newMessages.push({ id: `msg_${Date.now()}_${newMessages.length}`, type: 'emoji', url: emojiData.url, name: emojiData.name, time, incoming: true, sender: contact.name });
                                }
                            }
                        }
                        
                        state.currentChat.messages.push(...newMessages);
                        await updateChatList(newMessages.length > 0 ? (newMessages[newMessages.length-1].type === 'text' ? newMessages[newMessages.length-1].text : '[表情]') : '...', true);
                        switchView('chat', true);
                    } else if (rawReply) {
                         const time = new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
                         const reply = { id: `msg_${Date.now()}`, type:'text', text: rawReply, time, incoming: true, sender: contact.name };
                         state.currentChat.messages.push(reply);
                         await updateChatList(rawReply, true);
                         switchView('chat', true);
                    } else {
                        await showError("（魔法通讯受到了干扰...）");
                    }
                }
            } catch (e) {
                if(historyEl && historyEl.contains(typingEl)) historyEl.removeChild(typingEl);
                await showError(`（魔法通讯干扰: ${e.message}）`);
            }
        }
        
        async function addMessageToChat(msgData) {
            const time = new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'});
            const myNickname = state.currentChat.isTriwizard ? state.userProfile.name : (state.currentChat.myNickname || state.userProfile.name);
            const msg = { ...msgData, id: `msg_${Date.now()}`, time, incoming: false, sender: myNickname };
            state.currentChat.messages.push(msg);
            
            if (!state.currentChat.isTriwizard) {
                let lastMessageText = '[消息]';
                switch (msg.type) {
                    case 'text': lastMessageText = msg.text; break;
                    case 'image': lastMessageText = '[图片]'; break;
                    case 'emoji': lastMessageText = '[表情]'; break;
                    case 'gift': lastMessageText = '[礼物]'; break;
                }
                await updateChatList(lastMessageText, false);
            }
            switchView('chat', true);
        }
        async function updateContactIdReferences(oldId, newId) { 
            state.chats.forEach(chat => { if (chat.contactId === oldId) { chat.contactId = newId; chat.name = newId; } }); 
            await db.chats.where({ contactId: oldId }).modify({ contactId: newId, name: newId });
        }
        
        async function updateChatList(lastMessage, isIncoming) {
            const chat = state.currentChat;
            chat.lastMessage = lastMessage.length > 20 ? lastMessage.substring(0, 20) + "..." : lastMessage;
            chat.time = new Date().toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'});
            if (isIncoming) chat.unread = (chat.unread || 0) + 1;
            
            chat.isHidden = false;
            await db.chats.put(chat);
            state.chats = await db.chats.toArray();
        }
        
        async function generateAIFriendMoments() {
            const btn = document.getElementById('generateMomentsBtn');
            if(btn) { btn.innerText = "生成中..."; btn.disabled = true; }
            const potentialPosters = state.contacts.filter(c => 
                !c.oc || (c.oc && c.info && c.info.trim() !== '')
            );
            if (potentialPosters.length === 0) {
                alert("没有可发布动态的好友（请确保原创角色的“基本信息”已填写，才能激活他们）。");
                if(btn) { btn.innerText = "刷新好友动态"; btn.disabled = false; }
                return;
            }
            const triwizardMemoryPool = await getTriwizardMemoryPool();
            for (let i = 0; i < 3; i++) {
                const friend = potentialPosters[Math.floor(Math.random() * potentialPosters.length)];
                
                const recentHistory = await generateUnifiedHistoryText(friend.id, 15);
                
                const prompt = `# 任务：扮演角色并发布一条动态
    你正在扮演《哈利·波特》里的角色：${friend.name}。
    # 角色设定
    ${friend.info}
    # 你和玩家最近的共同记忆:
    ${recentHistory}
    # (背景信息) 三强争霸赛主要记忆:
    ${triwizardMemoryPool}
    # 你的任务
    基于你的角色设定和所有记忆，生成一条完全符合你人设和当前心境的动态【纯文本内容】。
    # 输出铁则 (ABSOLUTE MANDATORY RULES)
    1.  【绝对禁止】输出任何与动态内容无关的文字。
    2.  【绝对禁止】使用星号(*)描述动作或心理。
    3.  【绝对禁止】在内容前后添加任何标签、角色名或引号。
    4.  【绝对禁止】输出任何JSON或Markdown格式。
    # 现在，只输出纯文本动态。`;
                
                try {
                    const content = await callApi(prompt);
                    if(content) {
                        const cleanedContent = content.replace(/^(动态|内容|回复|我的动态)[:：\s]*/, '').trim();
                        if (cleanedContent) { 
                            const newMoment = { id: `fm_${Date.now()}_${i}`, name: friend.name, house: friend.house, time: `${Math.floor(Math.random()*50)+10}分钟前`, content: cleanedContent, comments: [], likedBy: [] };
                            state.friendMoments.unshift(newMoment);
                            await db.friendMoments.put(newMoment);
                        }
                    }
                } catch (e) {
                    alert(`生成动态失败: ${e.message}`);
                    break;
                }
            }
            if(state.currentView === 'moments') switchView('moments', true);
            if(btn) { btn.innerText = "刷新好友动态"; btn.disabled = false; }
        }
        async function getApiCommentForMoment(moment) {
            const p = state.userProfile;
            let commenter, prompt;
            const lastComment = moment.comments && moment.comments.length > 0 ? moment.comments[moment.comments.length - 1] : null;
            const triwizardMemoryPool = await getTriwizardMemoryPool();
            
            if (lastComment && lastComment.author === p.name && moment.name !== p.name) {
                commenter = state.contacts.find(c => c.name === moment.name);
                if (!commenter) return; 
                
                const sharedHistoryWithPlayer = await generateUnifiedHistoryText(commenter.id);
                prompt = `# 任务：扮演角色并回复评论
你【必须】扮演《哈利·波特》世界里的角色：${commenter.name}。
# 你和玩家 (${p.name}) 的共同记忆和最近事件:
${sharedHistoryWithPlayer || '无'}
# (背景信息) 三强争霸赛主要记忆:
${triwizardMemoryPool}
# 情景
这是你之前发布的动态: "${moment.content}"
你的朋友 ${p.name} 刚刚评论了: "${lastComment.text}"
# 你的任务
以 ${commenter.name} 的身份和口吻，【只针对】${p.name} 的这条最新评论进行回复。
# 输出铁则 (ABSOLUTE MANDATORY RULES)
1.  你的最终输出【必须且只能】是回复的【纯文本内容】。
2.  【绝对禁止】添加任何前缀，如“评论:”或你自己的名字。
3.  【绝对禁止】输出任何JSON或Markdown格式。
# 现在，只输出纯文本评论。`;
                 try {
                    const rawResponse = await callApi(prompt);
                    if (rawResponse) {
                        const text = rawResponse.trim().replace(/^.*?:/, '').trim();
                        if (text) {
                            if (!moment.comments) moment.comments = [];
                            moment.comments.push({ author: commenter.name, text: text, replyTo: p.name });
                        }
                    }
                } catch(e) { console.error("生成AI评论失败(场景1):", e); }
            } else {
                const potentialCommenters = state.contacts.filter(c => 
                    c.name !== moment.name && 
                    c.name !== p.name && 
                    !(moment.comments || []).some(com => com.author === c.name) &&
                    (!c.oc || (c.oc && c.info && c.info.trim() !== '')) &&
                    !(moment.blockedContactIds || []).includes(c.id) 
                ).sort(() => 0.5 - Math.random()); 
                if (potentialCommenters.length === 0) return;
                
                const replyCount = Math.min(potentialCommenters.length, Math.floor(Math.random() * 3) + 3); 
                const commentersToReply = potentialCommenters.slice(0, replyCount);
                for (const commenter of commentersToReply) {
                    const commentsContext = (moment.comments || []).map(c => `${c.author}${c.replyTo ? ` @ ${c.replyTo}`: ''}: ${c.text}`).join('\n');
                    
                    const sharedHistoryWithPlayer = await generateUnifiedHistoryText(commenter.id);
                    prompt = `# 任务：扮演角色并评论动态
你【必须】扮演《哈利·波特》世界里的角色：${commenter.name}。
# 角色设定
${commenter.info}
# 你和玩家 (${p.name}) 的共同记忆和最近事件:
${sharedHistoryWithPlayer || '无'}
# (背景信息) 三强争霸赛主要记忆:
${triwizardMemoryPool}
# 情景
你的朋友 ${moment.name} 发布了一条动态。
- 动态内容: "${moment.content}"
- 已有评论:
${commentsContext || '（还没有评论）'}
# 你的任务
以 ${commenter.name} 的身份和口吻，针对【动态内容】或【已有评论】，撰写一条唯一的、符合人设的评论。
# 输出铁则 (ABSOLUTE MANDATORY RULES)
1.  你的最终输出【必须且只能】是评论的【纯文本内容】。
2.  【绝对禁止】添加任何前缀，比如你的名字、"评论:" 等。
3.  【绝对禁止】输出任何JSON或Markdown格式。
# 现在，只输出纯文本评论。`;
                     try {
                        const rawResponse = await callApi(prompt);
                        if (rawResponse) {
                            let text = rawResponse.trim().replace(/^.*?:/, '').trim();
                            let replyTo = null;
                            const replyMatch = text.match(/^@(\S+)\s/);
                            if (replyMatch) {
                                replyTo = replyMatch[1];
                                text = text.substring(replyMatch[0].length);
                            }
                            if (text) {
                                if (!moment.comments) moment.comments = [];
                                moment.comments.push({ author: commenter.name, text: text, replyTo: replyTo });
                            }
                        }
                    } catch(e) { console.error("生成AI评论失败(场景2):", e); }
                }
            }
            
            const isMyMoment = state.myMoments.some(m => m.id === moment.id);
            if (isMyMoment) await db.myMoments.put(moment);
            else await db.friendMoments.put(moment);
            if(state.currentView === 'moments') switchView('moments', true);
        }
        
        function renderEmojiPanel() {
            const grid = document.getElementById('emojiGrid');
            grid.innerHTML = '';
            const emojis = state.userProfile.customEmojis || {};
            Object.entries(emojis).forEach(([id, data]) => {
                const item = document.createElement('img');
                item.src = data.url;
                item.title = data.name;
                item.className = 'emoji-item';
                item.onclick = () => sendEmojiMessage(id);
                grid.appendChild(item);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'emoji-item emoji-item-add';
            addBtn.innerHTML = '<i class="fas fa-plus"></i>';
            addBtn.onclick = () => showAddEmojiModal();
            grid.prepend(addBtn);
        }
        function showAddEmojiModal() {
            showDialog(`<div class="dialog-title">添加表情包</div>
                        <div class="form-group"><label>表情名称/描述</label><input type="text" id="emojiName" placeholder="例如：开心"></div>
                        <div class="form-group"><label>表情图片URL</label><input type="text" id="emojiUrl" placeholder="https://..."></div>
                        <div style="text-align:center; margin: 10px 0;">或</div>
                        <div class="form-group"><label>上传图片文件</label><input type="file" id="emojiUpload" accept="image/*"></div>
                        <div class="dialog-actions"><button class="dialog-btn cancel-btn">取消</button><button id="confirmAddEmoji" class="dialog-btn">添加</button></div>`);
            
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('confirmAddEmoji').onclick = async () => {
                const name = document.getElementById('emojiName').value.trim();
                let url = document.getElementById('emojiUrl').value.trim();
                const file = document.getElementById('emojiUpload').files[0];
                if (!name) return alert('表情名称不能为空');
                if (!url && !file) return alert('请提供URL或上传文件');
                if (file) {
                    url = await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });
                }
                const id = `emoji_${Date.now()}`;
                if (!state.userProfile.customEmojis) state.userProfile.customEmojis = {};
                state.userProfile.customEmojis[id] = { name, url };
                await db.userProfile.put({id: 'main', ...state.userProfile});
                hideDialog();
                renderEmojiPanel();
            };
        }
        function showDeleteEmojiModal() {
            const emojis = state.userProfile.customEmojis || {};
            if (Object.keys(emojis).length === 0) {
                return alert("没有可删除的自定义表情。");
            }
            
            let emojiChecklistHtml = '<div style="max-height: 30vh; overflow-y: auto;">';
            Object.entries(emojis).forEach(([id, data]) => {
                emojiChecklistHtml += `<div style="display: flex; align-items: center; margin-bottom: 8px;">
                                           <input type="checkbox" id="del_${id}" value="${id}" name="emoji-to-delete" style="margin-right: 10px;">
                                           <label for="del_${id}" style="display: flex; align-items: center; gap: 8px;">
                                               <img src="${data.url}" style="width: 30px; height: 30px; object-fit: contain;">
                                               <span>${data.name}</span>
                                           </label>
                                       </div>`;
            });
            emojiChecklistHtml += '</div>';
            showDialog(`<div class="dialog-title">删除表情包</div>
                        ${emojiChecklistHtml}
                        <div class="dialog-actions">
                            <button class="dialog-btn cancel-btn">取消</button>
                            <button id="confirmDeleteEmoji" class="dialog-btn logout">删除选中</button>
                        </div>`);
            
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('confirmDeleteEmoji').onclick = async () => {
                const selected = document.querySelectorAll('input[name="emoji-to-delete"]:checked');
                if (selected.length === 0) return alert("请选择要删除的表情。");
                selected.forEach(checkbox => {
                    delete state.userProfile.customEmojis[checkbox.value];
                });
                
                await db.userProfile.put({id: 'main', ...state.userProfile});
                hideDialog();
                renderEmojiPanel();
                alert(`${selected.length}个表情已删除。`);
            };
        }
        async function sendEmojiMessage(id) {
            const emojiData = (state.userProfile.customEmojis || {})[id];
            if (emojiData) {
                await addMessageToChat({ type: 'emoji', ...emojiData, id: id });
                document.getElementById('emojiPanel').style.display = 'none';
            }
        }
        
        function showGroupCreationDialog() {
            const singleContacts = state.contacts; 
            if (singleContacts.length < 2) {
                return alert("至少需要2个好友才能创建群聊。");
            }
            let contactsHtml = '<div style="max-height: 40vh; overflow-y: auto; text-align: left;">';
            singleContacts.forEach(contact => {
                contactsHtml += `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="member_${contact.id}" value="${contact.id}" name="group-member" style="margin-right: 10px; width: 18px; height: 18px;">
                        <label for="member_${contact.id}" style="display: flex; align-items: center; gap: 8px;">
                            <div class="chat-avatar avatar" style="${getAvatarStyle(contact.avatar, '#ccc')}; width:30px; height:30px; font-size: 16px; flex-shrink: 0;">${!contact.avatar ? contact.icon : ''}</div>
                            <span>${contact.name}</span>
                        </label>
                    </div>`;
            });
            contactsHtml += '</div>';
            showDialog(`
                <div class="dialog-title">创建群聊</div>
                <div class="form-group">
                    <label>群聊名称</label>
                    <input type="text" id="groupNameInput" placeholder="例如：斯莱特林四年级">
                </div>
                <div class="form-group">
                    <label>选择群成员 (至少2位)</label>
                    ${contactsHtml}
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn cancel-btn">取消</button>
                    <button class="dialog-btn" id="confirmCreateGroup">创建</button>
                </div>
            `);
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('confirmCreateGroup').onclick = createGroupChat;
        }
        async function createGroupChat() {
            const groupName = document.getElementById('groupNameInput').value.trim();
            if (!groupName) {
                return alert("请输入群聊名称。");
            }
            const selected = document.querySelectorAll('input[name="group-member"]:checked');
            if (selected.length < 2) {
                return alert("至少需要选择2位成员。");
            }
            const memberIds = Array.from(selected).map(cb => cb.value);
            const members = memberIds.map(id => {
                const contact = state.contacts.find(c => c.id === id);
                return { 
                    id: contact.id, 
                    name: contact.name,
                    nickname: null,
                    persona: contact.info,
                    sharedHistory: contact.sharedHistory,
                };
            });
            const newGroup = {
                id: `group_${Date.now()}`,
                name: groupName,
                isGroup: true,
                members: members,
                contactId: null, 
                lastMessage: '群聊已创建',
                time: new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
                messages: [],
                background: null,
                isPinned: false,
                summary: "",
                isHidden: false,
                isOfflineMode: false,
                avatar: null,
                myNickname: null
            };
            await db.chats.add(newGroup);
            state.chats.push(newGroup);
            hideDialog();
            const contactsContent = document.getElementById('contactsContent');
            if(contactsContent) {
                document.querySelector('.tab[data-tab="groups"]').click();
            }
        }
        function showManageGroupsDialog() {
            let dialogHtml = `<div class="dialog-title">管理分组</div><div class="manage-groups-list">`;
        
            const sortedGroups = [...state.groups].sort((a, b) => (b.isPinned || 0) - (a.isPinned || 0));
            const allContactIdsInGroups = new Set(state.groups.flatMap(g => g.contactIds));
            const ungroupedContacts = state.contacts.filter(contact => !allContactIdsInGroups.has(contact.id));
        
            sortedGroups.forEach(group => {
                dialogHtml += generateGroupManageItemHtml(group);
            });
            dialogHtml += generateGroupManageItemHtml({ name: '未分组', id: 'ungrouped' }, ungroupedContacts);
        
            dialogHtml += `</div>
                <div class="dialog-actions">
                    <button class="dialog-btn" id="addNewGroupInDialog">添加分组</button>
                </div>`;
            showDialog(dialogHtml, '600px');
        
            document.querySelectorAll('.group-manage-header').forEach(header => {
                header.addEventListener('click', () => {
                    const membersDiv = header.nextElementSibling;
                    const arrow = header.querySelector('.header-arrow');
                    membersDiv.classList.toggle('expanded');
                    arrow.classList.toggle('expanded');
                });
                const groupId = header.dataset.groupId;
                if (groupId !== 'ungrouped') {
                     addLongPressListener(header, (e) => {
                        showContextMenu(e, 'manageGroupHeader', groupId);
                    });
                }
            });
            
            document.getElementById('addNewGroupInDialog').onclick = () => {
                 showAddGroupDialog();
            };
        }
        
        function generateGroupManageItemHtml(group, membersOverride = null) {
            let members;
            if (membersOverride) {
                members = membersOverride;
            } else {
                members = state.contacts.filter(c => group.contactIds.includes(c.id));
            }
            const pinIcon = group.isPinned ? '<i class="fas fa-thumbtack"></i>' : '';
            let membersHtml = members.map(contact => `
                <div class="group-member-item">
                    <div class="avatar group-member-avatar" style="${getAvatarStyle(contact.avatar, 'var(--theme-bubble)')}">${!contact.avatar ? contact.icon : ''}</div>
                    <span>${contact.name}</span>
                </div>
            `).join('');
        
            if (members.length === 0) {
                membersHtml = `<div class="group-member-item" style="opacity:0.7;">（空）</div>`;
            }
        
            return `
                <div class="group-manage-item">
                    <div class="group-manage-header" data-group-id="${group.id}">
                        <span class="group-manage-header-name">${pinIcon} ${group.name} (${members.length})</span>
                        <i class="fas fa-chevron-down header-arrow"></i>
                    </div>
                    <div class="group-manage-members">
                        ${membersHtml}
                    </div>
                </div>`;
        }
        
        function showAddGroupDialog() {
            const dialogHtml = `
                <div class="dialog-title">添加分组</div>
                <div class="form-group">
                    <label for="newGroupName">分组名称</label>
                    <input type="text" id="newGroupName" placeholder="请输入新分组的名称">
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn cancel-btn">取消</button>
                    <button class="dialog-btn" id="confirmAddGroup">确认</button>
                </div>
            `;
            showDialog(dialogHtml);
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('confirmAddGroup').onclick = async () => {
                const groupName = document.getElementById('newGroupName').value.trim();
                if (groupName) {
                    const newGroup = {
                        id: `group_custom_${Date.now()}`, name: groupName, contactIds: [],
                        isDeletable: true, isRenamable: true, isPinned: false
                    };
                    await db.groups.put(newGroup);
                    state.groups.push(newGroup);
                    hideDialog();
                    showManageGroupsDialog();
                    renderGroupedContacts();
                } else {
                    alert("分组名称不能为空。");
                }
            };
        }
        function showGroupRenameDialog(groupId) {
            const group = state.groups.find(g => g.id === groupId);
            if (!group) return;
            const dialogHtml = `
                <div class="dialog-title">重命名分组</div>
                <div class="form-group">
                    <label for="newGroupName">分组名称</label>
                    <input type="text" id="newGroupName" value="${group.name}">
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn cancel-btn">取消</button>
                    <button class="dialog-btn" id="confirmRenameGroup">确认</button>
                </div>
            `;
            showDialog(dialogHtml);
            document.querySelector('.dialog-btn.cancel-btn').onclick = hideDialog;
            document.getElementById('confirmRenameGroup').onclick = async () => {
                const newName = document.getElementById('newGroupName').value.trim();
                if (newName) {
                    group.name = newName;
                    await db.groups.put(group);
                    hideDialog();
                    showManageGroupsDialog();
                    renderGroupedContacts();
                } else {
                     alert("分组名称不能为空。");
                }
            };
        }
        function showMoveToGroupDialog(contactId) {
            const contact = state.contacts.find(c => c.id === contactId);
            if (!contact) return;
        
            let currentGroupId = 'ungrouped';
            for (const group of state.groups) {
                if (group.contactIds.includes(contactId)) {
                    currentGroupId = group.id;
                    break;
                }
            }
        
            let groupsHtml = `<div style="max-height: 50vh; overflow-y: auto;">`;
            state.groups.forEach(group => {
                const isCurrent = group.id === currentGroupId;
                groupsHtml += `<div class="move-to-group-option ${isCurrent ? 'current' : ''}" data-group-id="${group.id}">
                                ${group.name} ${isCurrent ? '<i class="fas fa-check"></i>' : ''}
                               </div>`;
            });
            const isUngrouped = currentGroupId === 'ungrouped';
            groupsHtml += `<div class="move-to-group-option ${isUngrouped ? 'current' : ''}" data-group-id="ungrouped">
                           未分组 ${isUngrouped ? '<i class="fas fa-check"></i>' : ''}
                           </div>`;
            groupsHtml += `</div>`;
        
            const dialogHtml = `<div class="dialog-title">移动 ${contact.name} 到</div>${groupsHtml}`;
            showDialog(dialogHtml);
        
            document.querySelectorAll('.move-to-group-option').forEach(option => {
                option.onclick = async () => {
                    const newGroupId = option.dataset.groupId;
                    if (newGroupId !== currentGroupId) {
                        await moveContactToGroup(contactId, newGroupId);
                    }
                    hideDialog();
                };
            });
        }
        function showGroupSettingsDialog() {
            const chat = state.currentChat;
            const dialogHtml = `
                <div class="dialog-title">${chat.name} 设置</div>
                <div class="tabs" id="group-settings-tabs">
                    <div class="tab active" data-tab-content="group-general-settings">常规</div>
                    <div class="tab" data-tab-content="group-members-list">成员</div>
                </div>
                <div id="group-settings-content"></div>
            `;
            showDialog(dialogHtml);
            renderGroupSettingsContent('group-general-settings');
            document.querySelectorAll('#group-settings-tabs .tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelector('#group-settings-tabs .tab.active').classList.remove('active');
                    this.classList.add('active');
                    renderGroupSettingsContent(this.dataset.tabContent);
                });
            });
        }
        
        function renderGroupSettingsContent(tabId) {
            const contentEl = document.getElementById('group-settings-content');
            const chat = state.currentChat;
            let html = '';
        
            if (tabId === 'group-general-settings') {
                html = `
                    <div class="form-group">
                        <label for="groupNameEdit">群名</label>
                        <input type="text" id="groupNameEdit" value="${chat.name}">
                    </div>
                    <div class="form-group">
                        <label for="myNicknameEdit">我的群昵称</label>
                        <input type="text" id="myNicknameEdit" value="${chat.myNickname || ''}" placeholder="默认使用角色名">
                    </div>
                    <div class="form-group">
                        <label>群头像</label>
                        <div style="display:flex; align-items:center; gap: 15px;">
                            <div class="chat-avatar avatar" id="groupAvatarPreview" style="${getAvatarStyle(chat.avatar, '#333')}">${!chat.avatar ? '👥' : ''}</div>
                            <input type="file" id="groupAvatarUpload" class="hidden" accept="image/*">
                            <button class="btn primary" onclick="document.getElementById('groupAvatarUpload').click()">上传头像</button>
                        </div>
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn" id="saveGeneralGroupSettings">保存</button>
                    </div>
                `;
                contentEl.innerHTML = html;
        
                document.getElementById('groupAvatarUpload').onchange = (e) => handleAvatarUpload(e, dataUrl => {
                    document.getElementById('groupAvatarPreview').style.backgroundImage = `url(${dataUrl})`;
                    document.getElementById('groupAvatarPreview').textContent = '';
                    document.getElementById('groupAvatarPreview').dataset.newAvatar = dataUrl;
                });
        
                document.getElementById('saveGeneralGroupSettings').onclick = async () => {
                    chat.name = document.getElementById('groupNameEdit').value.trim();
                    chat.myNickname = document.getElementById('myNicknameEdit').value.trim() || null;
                    const newAvatar = document.getElementById('groupAvatarPreview').dataset.newAvatar;
                    if (newAvatar) {
                        chat.avatar = newAvatar;
                    }
                    await db.chats.put(chat);
                    hideDialog();
                    alert("群设置已保存！");
                    switchView('chat', true); 
                };
            } else if (tabId === 'group-members-list') {
                 html = `<div style="max-height: 40vh; overflow-y: auto;">`;
                chat.members.forEach(member => {
                    let addFriendButtonHtml = '';
                    if (chat.id === 'group_hogwarts_default') {
                        const isDumbledore = member.id === 'virtual_dumbledore';
                        const isFriend = state.contacts.some(c => c.id === member.id);
                        if (!isDumbledore && !isFriend) {
                            addFriendButtonHtml = `<button class="add-friend-btn" data-member-id="${member.id}" style="background: var(--theme-light); color: white; border: none; border-radius: 8px; padding: 4px 8px; font-size: 12px; cursor: pointer;">添加好友</button>`;
                        }
                    }
                    html += `
                        <div class="chat-item" style="padding: 8px; cursor: default; display: flex; justify-content: space-between; align-items: center;">
                            <div class="chat-content" data-member-id="${member.id}" style="cursor: pointer;">
                                <strong>${member.nickname || member.name}</strong>
                                ${member.nickname ? `<div style="font-size: 12px; opacity: 0.7;">${member.name}</div>` : ''}
                            </div>
                            ${addFriendButtonHtml}
                        </div>
                    `;
                });
                html += `</div>`;
                if (chat.id.startsWith('group_') && !chat.id.endsWith('_default')) {
                    html += `<div class="dialog-actions"><button class="dialog-btn" id="manageMembersBtn">管理群成员</button></div>`;
                }
                contentEl.innerHTML = html;
                
                contentEl.querySelectorAll('.chat-content[data-member-id]').forEach(item => {
                    item.onclick = () => showEditGroupMemberDialog(item.dataset.memberId);
                });
                if (chat.id.startsWith('group_') && !chat.id.endsWith('_default')) {
                    document.getElementById('manageMembersBtn').onclick = () => showManageMembersDialog();
                }
                contentEl.querySelectorAll('.add-friend-btn').forEach(button => {
                    button.onclick = async (e) => {
                        const memberId = e.currentTarget.dataset.memberId;
                        await addFriendFromGroup(memberId);
                        renderGroupSettingsContent('group-members-list'); 
                    };
                });
            }
        }
        
        function showEditGroupMemberDialog(memberId) {
            const chat = state.currentChat;
            const member = chat.members.find(m => m.id === memberId);
            const contact = state.contacts.find(c => c.id === memberId);
            const initialPersona = contact ? contact.info : '';
            const masterHistory = contact ? contact.sharedHistory : '';
        
            const dialogHtml = `
                <div class="dialog-title">编辑成员 - ${member.name}</div>
                <div class="form-group">
                    <label>群昵称</label>
                    <input type="text" id="memberNicknameEdit" value="${member.nickname || ''}">
                </div>
                <div class="form-group">
                    <label>群成员人设 (会覆盖好友信息)</label>
                    <textarea id="memberPersonaEdit" rows="4" placeholder="默认: ${initialPersona}">${member.persona || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>共同经历 (将同步更新至该角色的所有聊天中)</label>
                    <textarea id="memberHistoryEdit" rows="3" placeholder="无共同记忆">${masterHistory || ''}</textarea>
                </div>
                <div class="dialog-actions">
                    <button class="dialog-btn" id="saveMemberSettings">保存</button>
                </div>
            `;
            showDialog(dialogHtml);
        
            document.getElementById('saveMemberSettings').onclick = async () => {
                member.nickname = document.getElementById('memberNicknameEdit').value.trim() || null;
                member.persona = document.getElementById('memberPersonaEdit').value.trim() || null;
                const newHistory = document.getElementById('memberHistoryEdit').value.trim() || null;
                const contactToUpdate = state.contacts.find(c => c.id === member.id);
                if (contactToUpdate) {
                    contactToUpdate.sharedHistory = newHistory;
                    await db.contacts.put(contactToUpdate);
                }
                
                member.sharedHistory = null; 
                
                await db.chats.put(chat);
                hideDialog();
                showGroupSettingsDialog(); 
            };
        }
        
               function showManageMembersDialog() {
            const chat = state.currentChat;
            let membersHtml = `<div style="max-height: 25vh; overflow-y: auto;">`;
            chat.members.forEach(member => {
                membersHtml += `
                    <div style="display:flex; justify-content: space-between; align-items: center; padding: 5px; border-bottom: 1px solid var(--theme-bubble);">
                        <span>${member.nickname || member.name}</span>
                        <button class="btn logout" data-member-id="${member.id}" style="padding: 4px 8px; font-size: 12px;">删除</button>
                    </div>
                `;
            });
            membersHtml += `</div>`;
        
            const dialogHtml = `
                <div class="dialog-title">管理群成员</div>
                ${membersHtml}
                <div class="dialog-actions" style="margin-top: 25px;">
                    <button class="dialog-btn" id="addFromFriendsBtn">添加好友</button>
                    <button class="dialog-btn" id="addVirtualBtn">添加虚拟人员</button>
                </div>
            `;
            showDialog(dialogHtml, '600px');
        
            document.querySelectorAll('.btn.logout[data-member-id]').forEach(btn => {
                btn.onclick = async (e) => {
                    const memberId = e.currentTarget.dataset.memberId;
                    const memberIndex = chat.members.findIndex(m => m.id === memberId);
                    if (memberIndex > -1) {
                        chat.members.splice(memberIndex, 1);
                        await db.chats.put(chat);
                        showManageMembersDialog(); 
                    }
                };
            });
        
            document.getElementById('addFromFriendsBtn').onclick = () => {
                const availableFriends = state.contacts.filter(c => !chat.members.some(m => m.id === c.id));
                let friendsHtml = `<div style="max-height: 40vh; overflow-y: auto;">`;
                availableFriends.forEach(friend => {
                    friendsHtml += `
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <input type="checkbox" id="add_${friend.id}" value="${friend.id}" name="friend-to-add" style="margin-right: 10px;">
                            <label for="add_${friend.id}">${friend.name}</label>
                        </div>`;
                });
                friendsHtml += `</div>`;
                showDialog(`
                    <div class="dialog-title">从好友列表添加</div>
                    ${friendsHtml}
                    <div class="dialog-actions">
                        <button class="dialog-btn" id="confirmAddFriends">确认添加</button>
                    </div>
                `);
                document.getElementById('confirmAddFriends').onclick = async () => {
                    const selected = document.querySelectorAll('input[name="friend-to-add"]:checked');
                    selected.forEach(checkbox => {
                        const contact = state.contacts.find(c => c.id === checkbox.value);
                        if (contact) {
                            chat.members.push({ id: contact.id, name: contact.name, nickname: null, persona: contact.info, sharedHistory: contact.sharedHistory });
                        }
                    });
                    await db.chats.put(chat);
                    hideDialog();
                    showManageMembersDialog();
                };
            };
        
            document.getElementById('addVirtualBtn').onclick = () => {
                const dialogHtml = `
                    <div class="dialog-title">添加虚拟人员</div>
                    <div class="form-group">
                        <label>姓名</label>
                        <input type="text" id="virtualMemberNameInput" placeholder="输入姓名">
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn cancel-btn" id="cancelAddVirtual">取消</button>
                        <button class="dialog-btn" id="confirmAddVirtualMember">确认</button>
                    </div>`;
                showDialog(dialogHtml);
                document.getElementById('cancelAddVirtual').onclick = hideDialog;
                document.getElementById('confirmAddVirtualMember').onclick = async () => {
                    const name = document.getElementById('virtualMemberNameInput').value.trim();
                    if (name) {
                        const newMember = {
                            id: `virtual_${Date.now()}`,
                            name: name,
                            nickname: null, persona: null, sharedHistory: null
                        };
                        chat.members.push(newMember);
                        await db.chats.put(chat);
                        hideDialog();
                        showManageMembersDialog();
                    } else {
                        alert("姓名不能为空。");
                    }
                };
            };
        }
        async function deleteGroupChat(chatId) {
             if (confirm('确定要永久删除这个群聊吗？此操作不可恢复。')) {
                await db.chats.delete(chatId);
                state.chats = state.chats.filter(c => c.id !== chatId);
                alert("群聊已删除。");
                if (state.currentView === 'contacts') {
                    renderGroupsList();
                } else {
                    switchView('messages', true);
                }
            }
        }
        async function addFriendFromGroup(memberId) {
            if (state.contacts.some(c => c.id === memberId)) {
                alert("此人已是您的好友。");
                return;
            }
            const allDefaultContacts = Object.values(getDefaultContacts()).flat();
            const contactDataToAdd = allDefaultContacts.find(c => c.id === memberId);
            if (!contactDataToAdd) {
                alert("错误：未找到要添加的角色数据。");
                console.error("未能从默认联系人中找到ID为: ", memberId, " 的角色");
                return;
            }
            
            contactDataToAdd.isPinned = false;
            state.contacts.push(contactDataToAdd);
            await db.contacts.put(contactDataToAdd);
            alert(`${contactDataToAdd.name} 已成功添加到您的好友列表！`);
        }
        
        function renderApp(appInitialized) { 
            if (!appInitialized) {
                appRoot.innerHTML = setupTemplate; 
                bindSetupEvents(); 
                applyHouseTheme('slytherin'); 
            } else { 
                appRoot.innerHTML = mainTemplate; 
                bindMainEvents(); 
            } 
        }
        
        async function initialize() {
            try {
                const isInitialized = await loadDataFromDB();
                renderApp(isInitialized);
                
                appHasInitialized = true;
                const splashScreen = document.getElementById('splash-screen');
                if (splashScreen) {
                    splashScreen.classList.add('hidden');
                    setTimeout(() => {
                        splashScreen.style.display = 'none';
                    }, 500);
                }
            } catch (error) {
                 const splashScreen = document.getElementById('splash-screen');
                 if(splashScreen){
                    splashScreen.innerHTML = `<div style="color: #ff4d4d; text-align: center; padding: 20px;"><h3>应用初始化失败</h3><p style="font-size: 12px; margin-top: 15px;">${error.stack}</p></div>`;
                 }
            }
        }
        initialize();
    })();
}
window.onload = startApp;
</script>
</body>
</html>